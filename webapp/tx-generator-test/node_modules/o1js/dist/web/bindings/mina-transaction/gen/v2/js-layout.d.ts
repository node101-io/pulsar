import { BindingsType } from '../../v2/schema.js';
import { Actions, AuthRequired, Bool, Events, Field, Int64, Option, PublicKey, Range, StateHash, TokenId, TokenSymbol, UInt32, UInt64, ZkappUri } from '../../v2/leaves.js';
export { Types, ZkappCommand, ZkappFeePayer, FeePayerBody, ZkappAccountUpdate, AccountUpdateBody, AccountUpdateModification, VerificationKeyWithHash, Permissions, VerificationKeyPermission, Timing, Preconditions, NetworkPrecondition, EpochDataPrecondition, EpochLedgerPrecondition, AccountPrecondition, MayUseToken, AuthorizationKindStructured, Control, Account, AccountTiming, ZkappAccount, };
type FeePayerBody = {
    publicKey: PublicKey;
    fee: UInt64;
    validUntil: UInt32 | undefined;
    nonce: UInt32;
};
declare const FeePayerBody: BindingsType.Object<FeePayerBody>;
type VerificationKeyWithHash = {
    data: string;
    hash: Field;
};
declare const VerificationKeyWithHash: BindingsType.Object<VerificationKeyWithHash>;
type VerificationKeyPermission = {
    auth: AuthRequired;
    txnVersion: UInt32;
};
declare const VerificationKeyPermission: BindingsType.Object<VerificationKeyPermission>;
type Timing = {
    initialMinimumBalance: UInt64;
    cliffTime: UInt32;
    cliffAmount: UInt64;
    vestingPeriod: UInt32;
    vestingIncrement: UInt64;
};
declare const Timing: BindingsType.Object<Timing>;
type EpochLedgerPrecondition = {
    hash: Option<Field>;
    totalCurrency: Option<Range<UInt64>>;
};
declare const EpochLedgerPrecondition: BindingsType.Object<EpochLedgerPrecondition>;
type AccountPrecondition = {
    balance: Option<Range<UInt64>>;
    nonce: Option<Range<UInt32>>;
    receiptChainHash: Option<Field>;
    delegate: Option<PublicKey>;
    state: Option<Field>[];
    actionState: Option<Field>;
    provedState: Option<Bool>;
    isNew: Option<Bool>;
};
declare const AccountPrecondition: BindingsType.Object<AccountPrecondition>;
type MayUseToken = {
    parentsOwnToken: Bool;
    inheritFromParent: Bool;
};
declare const MayUseToken: BindingsType.Object<MayUseToken>;
type AuthorizationKindStructured = {
    isSigned: Bool;
    isProved: Bool;
    verificationKeyHash: Field;
};
declare const AuthorizationKindStructured: BindingsType.Object<AuthorizationKindStructured>;
type Control = {
    proof: string | undefined;
    signature: string | undefined;
};
declare const Control: BindingsType.Object<Control>;
type AccountTiming = {
    isTimed: Bool;
    initialMinimumBalance: UInt64;
    cliffTime: UInt32;
    cliffAmount: UInt64;
    vestingPeriod: UInt32;
    vestingIncrement: UInt64;
};
declare const AccountTiming: BindingsType.Object<AccountTiming>;
type ZkappFeePayer = {
    body: {
        publicKey: PublicKey;
        fee: UInt64;
        validUntil: UInt32 | undefined;
        nonce: UInt32;
    };
    authorization: string;
};
declare const ZkappFeePayer: BindingsType.Object<ZkappFeePayer>;
type Permissions = {
    editState: AuthRequired;
    access: AuthRequired;
    send: AuthRequired;
    receive: AuthRequired;
    setDelegate: AuthRequired;
    setPermissions: AuthRequired;
    setVerificationKey: {
        auth: AuthRequired;
        txnVersion: UInt32;
    };
    setZkappUri: AuthRequired;
    editActionState: AuthRequired;
    setTokenSymbol: AuthRequired;
    incrementNonce: AuthRequired;
    setVotingFor: AuthRequired;
    setTiming: AuthRequired;
};
declare const Permissions: BindingsType.Object<Permissions>;
type EpochDataPrecondition = {
    ledger: {
        hash: Option<Field>;
        totalCurrency: Option<Range<UInt64>>;
    };
    seed: Option<Field>;
    startCheckpoint: Option<Field>;
    lockCheckpoint: Option<Field>;
    epochLength: Option<Range<UInt32>>;
};
declare const EpochDataPrecondition: BindingsType.Object<EpochDataPrecondition>;
type ZkappAccount = {
    appState: Field[];
    verificationKey: {
        data: string;
        hash: Field;
    } | undefined;
    zkappVersion: UInt32;
    actionState: Field[];
    lastActionSlot: UInt32;
    provedState: Bool;
    zkappUri: string;
};
declare const ZkappAccount: BindingsType.Object<ZkappAccount>;
type AccountUpdateModification = {
    appState: Option<Field>[];
    delegate: Option<PublicKey>;
    verificationKey: Option<{
        data: string;
        hash: Field;
    }>;
    permissions: Option<{
        editState: AuthRequired;
        access: AuthRequired;
        send: AuthRequired;
        receive: AuthRequired;
        setDelegate: AuthRequired;
        setPermissions: AuthRequired;
        setVerificationKey: {
            auth: AuthRequired;
            txnVersion: UInt32;
        };
        setZkappUri: AuthRequired;
        editActionState: AuthRequired;
        setTokenSymbol: AuthRequired;
        incrementNonce: AuthRequired;
        setVotingFor: AuthRequired;
        setTiming: AuthRequired;
    }>;
    zkappUri: Option<ZkappUri>;
    tokenSymbol: Option<TokenSymbol>;
    timing: Option<{
        initialMinimumBalance: UInt64;
        cliffTime: UInt32;
        cliffAmount: UInt64;
        vestingPeriod: UInt32;
        vestingIncrement: UInt64;
    }>;
    votingFor: Option<StateHash>;
};
declare const AccountUpdateModification: BindingsType.Object<AccountUpdateModification>;
type NetworkPrecondition = {
    snarkedLedgerHash: Option<Field>;
    blockchainLength: Option<Range<UInt32>>;
    minWindowDensity: Option<Range<UInt32>>;
    totalCurrency: Option<Range<UInt64>>;
    globalSlotSinceGenesis: Option<Range<UInt32>>;
    stakingEpochData: {
        ledger: {
            hash: Option<Field>;
            totalCurrency: Option<Range<UInt64>>;
        };
        seed: Option<Field>;
        startCheckpoint: Option<Field>;
        lockCheckpoint: Option<Field>;
        epochLength: Option<Range<UInt32>>;
    };
    nextEpochData: {
        ledger: {
            hash: Option<Field>;
            totalCurrency: Option<Range<UInt64>>;
        };
        seed: Option<Field>;
        startCheckpoint: Option<Field>;
        lockCheckpoint: Option<Field>;
        epochLength: Option<Range<UInt32>>;
    };
};
declare const NetworkPrecondition: BindingsType.Object<NetworkPrecondition>;
type Account = {
    publicKey: PublicKey;
    tokenId: TokenId;
    tokenSymbol: string;
    balance: UInt64;
    nonce: UInt32;
    receiptChainHash: Field;
    delegate: PublicKey | undefined;
    votingFor: Field;
    timing: {
        isTimed: Bool;
        initialMinimumBalance: UInt64;
        cliffTime: UInt32;
        cliffAmount: UInt64;
        vestingPeriod: UInt32;
        vestingIncrement: UInt64;
    };
    permissions: {
        editState: AuthRequired;
        access: AuthRequired;
        send: AuthRequired;
        receive: AuthRequired;
        setDelegate: AuthRequired;
        setPermissions: AuthRequired;
        setVerificationKey: {
            auth: AuthRequired;
            txnVersion: UInt32;
        };
        setZkappUri: AuthRequired;
        editActionState: AuthRequired;
        setTokenSymbol: AuthRequired;
        incrementNonce: AuthRequired;
        setVotingFor: AuthRequired;
        setTiming: AuthRequired;
    };
    zkapp: {
        appState: Field[];
        verificationKey: {
            data: string;
            hash: Field;
        } | undefined;
        zkappVersion: UInt32;
        actionState: Field[];
        lastActionSlot: UInt32;
        provedState: Bool;
        zkappUri: string;
    } | undefined;
};
declare const Account: BindingsType.Object<Account>;
type Preconditions = {
    network: {
        snarkedLedgerHash: Option<Field>;
        blockchainLength: Option<Range<UInt32>>;
        minWindowDensity: Option<Range<UInt32>>;
        totalCurrency: Option<Range<UInt64>>;
        globalSlotSinceGenesis: Option<Range<UInt32>>;
        stakingEpochData: {
            ledger: {
                hash: Option<Field>;
                totalCurrency: Option<Range<UInt64>>;
            };
            seed: Option<Field>;
            startCheckpoint: Option<Field>;
            lockCheckpoint: Option<Field>;
            epochLength: Option<Range<UInt32>>;
        };
        nextEpochData: {
            ledger: {
                hash: Option<Field>;
                totalCurrency: Option<Range<UInt64>>;
            };
            seed: Option<Field>;
            startCheckpoint: Option<Field>;
            lockCheckpoint: Option<Field>;
            epochLength: Option<Range<UInt32>>;
        };
    };
    account: {
        balance: Option<Range<UInt64>>;
        nonce: Option<Range<UInt32>>;
        receiptChainHash: Option<Field>;
        delegate: Option<PublicKey>;
        state: Option<Field>[];
        actionState: Option<Field>;
        provedState: Option<Bool>;
        isNew: Option<Bool>;
    };
    validWhile: Option<Range<UInt32>>;
};
declare const Preconditions: BindingsType.Object<Preconditions>;
type AccountUpdateBody = {
    publicKey: PublicKey;
    tokenId: TokenId;
    update: {
        appState: Option<Field>[];
        delegate: Option<PublicKey>;
        verificationKey: Option<{
            data: string;
            hash: Field;
        }>;
        permissions: Option<{
            editState: AuthRequired;
            access: AuthRequired;
            send: AuthRequired;
            receive: AuthRequired;
            setDelegate: AuthRequired;
            setPermissions: AuthRequired;
            setVerificationKey: {
                auth: AuthRequired;
                txnVersion: UInt32;
            };
            setZkappUri: AuthRequired;
            editActionState: AuthRequired;
            setTokenSymbol: AuthRequired;
            incrementNonce: AuthRequired;
            setVotingFor: AuthRequired;
            setTiming: AuthRequired;
        }>;
        zkappUri: Option<ZkappUri>;
        tokenSymbol: Option<TokenSymbol>;
        timing: Option<{
            initialMinimumBalance: UInt64;
            cliffTime: UInt32;
            cliffAmount: UInt64;
            vestingPeriod: UInt32;
            vestingIncrement: UInt64;
        }>;
        votingFor: Option<StateHash>;
    };
    balanceChange: Int64;
    incrementNonce: Bool;
    events: Events;
    actions: Actions;
    callData: Field;
    callDepth: number;
    preconditions: {
        network: {
            snarkedLedgerHash: Option<Field>;
            blockchainLength: Option<Range<UInt32>>;
            minWindowDensity: Option<Range<UInt32>>;
            totalCurrency: Option<Range<UInt64>>;
            globalSlotSinceGenesis: Option<Range<UInt32>>;
            stakingEpochData: {
                ledger: {
                    hash: Option<Field>;
                    totalCurrency: Option<Range<UInt64>>;
                };
                seed: Option<Field>;
                startCheckpoint: Option<Field>;
                lockCheckpoint: Option<Field>;
                epochLength: Option<Range<UInt32>>;
            };
            nextEpochData: {
                ledger: {
                    hash: Option<Field>;
                    totalCurrency: Option<Range<UInt64>>;
                };
                seed: Option<Field>;
                startCheckpoint: Option<Field>;
                lockCheckpoint: Option<Field>;
                epochLength: Option<Range<UInt32>>;
            };
        };
        account: {
            balance: Option<Range<UInt64>>;
            nonce: Option<Range<UInt32>>;
            receiptChainHash: Option<Field>;
            delegate: Option<PublicKey>;
            state: Option<Field>[];
            actionState: Option<Field>;
            provedState: Option<Bool>;
            isNew: Option<Bool>;
        };
        validWhile: Option<Range<UInt32>>;
    };
    useFullCommitment: Bool;
    implicitAccountCreationFee: Bool;
    mayUseToken: {
        parentsOwnToken: Bool;
        inheritFromParent: Bool;
    };
    authorizationKind: {
        isSigned: Bool;
        isProved: Bool;
        verificationKeyHash: Field;
    };
};
declare const AccountUpdateBody: BindingsType.Object<AccountUpdateBody>;
type ZkappAccountUpdate = {
    body: {
        publicKey: PublicKey;
        tokenId: TokenId;
        update: {
            appState: Option<Field>[];
            delegate: Option<PublicKey>;
            verificationKey: Option<{
                data: string;
                hash: Field;
            }>;
            permissions: Option<{
                editState: AuthRequired;
                access: AuthRequired;
                send: AuthRequired;
                receive: AuthRequired;
                setDelegate: AuthRequired;
                setPermissions: AuthRequired;
                setVerificationKey: {
                    auth: AuthRequired;
                    txnVersion: UInt32;
                };
                setZkappUri: AuthRequired;
                editActionState: AuthRequired;
                setTokenSymbol: AuthRequired;
                incrementNonce: AuthRequired;
                setVotingFor: AuthRequired;
                setTiming: AuthRequired;
            }>;
            zkappUri: Option<ZkappUri>;
            tokenSymbol: Option<TokenSymbol>;
            timing: Option<{
                initialMinimumBalance: UInt64;
                cliffTime: UInt32;
                cliffAmount: UInt64;
                vestingPeriod: UInt32;
                vestingIncrement: UInt64;
            }>;
            votingFor: Option<StateHash>;
        };
        balanceChange: Int64;
        incrementNonce: Bool;
        events: Events;
        actions: Actions;
        callData: Field;
        callDepth: number;
        preconditions: {
            network: {
                snarkedLedgerHash: Option<Field>;
                blockchainLength: Option<Range<UInt32>>;
                minWindowDensity: Option<Range<UInt32>>;
                totalCurrency: Option<Range<UInt64>>;
                globalSlotSinceGenesis: Option<Range<UInt32>>;
                stakingEpochData: {
                    ledger: {
                        hash: Option<Field>;
                        totalCurrency: Option<Range<UInt64>>;
                    };
                    seed: Option<Field>;
                    startCheckpoint: Option<Field>;
                    lockCheckpoint: Option<Field>;
                    epochLength: Option<Range<UInt32>>;
                };
                nextEpochData: {
                    ledger: {
                        hash: Option<Field>;
                        totalCurrency: Option<Range<UInt64>>;
                    };
                    seed: Option<Field>;
                    startCheckpoint: Option<Field>;
                    lockCheckpoint: Option<Field>;
                    epochLength: Option<Range<UInt32>>;
                };
            };
            account: {
                balance: Option<Range<UInt64>>;
                nonce: Option<Range<UInt32>>;
                receiptChainHash: Option<Field>;
                delegate: Option<PublicKey>;
                state: Option<Field>[];
                actionState: Option<Field>;
                provedState: Option<Bool>;
                isNew: Option<Bool>;
            };
            validWhile: Option<Range<UInt32>>;
        };
        useFullCommitment: Bool;
        implicitAccountCreationFee: Bool;
        mayUseToken: {
            parentsOwnToken: Bool;
            inheritFromParent: Bool;
        };
        authorizationKind: {
            isSigned: Bool;
            isProved: Bool;
            verificationKeyHash: Field;
        };
    };
    authorization: {
        proof: string | undefined;
        signature: string | undefined;
    };
};
declare const ZkappAccountUpdate: BindingsType.Object<ZkappAccountUpdate>;
type ZkappCommand = {
    feePayer: {
        body: {
            publicKey: PublicKey;
            fee: UInt64;
            validUntil: UInt32 | undefined;
            nonce: UInt32;
        };
        authorization: string;
    };
    accountUpdates: {
        body: {
            publicKey: PublicKey;
            tokenId: TokenId;
            update: {
                appState: Option<Field>[];
                delegate: Option<PublicKey>;
                verificationKey: Option<{
                    data: string;
                    hash: Field;
                }>;
                permissions: Option<{
                    editState: AuthRequired;
                    access: AuthRequired;
                    send: AuthRequired;
                    receive: AuthRequired;
                    setDelegate: AuthRequired;
                    setPermissions: AuthRequired;
                    setVerificationKey: {
                        auth: AuthRequired;
                        txnVersion: UInt32;
                    };
                    setZkappUri: AuthRequired;
                    editActionState: AuthRequired;
                    setTokenSymbol: AuthRequired;
                    incrementNonce: AuthRequired;
                    setVotingFor: AuthRequired;
                    setTiming: AuthRequired;
                }>;
                zkappUri: Option<ZkappUri>;
                tokenSymbol: Option<TokenSymbol>;
                timing: Option<{
                    initialMinimumBalance: UInt64;
                    cliffTime: UInt32;
                    cliffAmount: UInt64;
                    vestingPeriod: UInt32;
                    vestingIncrement: UInt64;
                }>;
                votingFor: Option<StateHash>;
            };
            balanceChange: Int64;
            incrementNonce: Bool;
            events: Events;
            actions: Actions;
            callData: Field;
            callDepth: number;
            preconditions: {
                network: {
                    snarkedLedgerHash: Option<Field>;
                    blockchainLength: Option<Range<UInt32>>;
                    minWindowDensity: Option<Range<UInt32>>;
                    totalCurrency: Option<Range<UInt64>>;
                    globalSlotSinceGenesis: Option<Range<UInt32>>;
                    stakingEpochData: {
                        ledger: {
                            hash: Option<Field>;
                            totalCurrency: Option<Range<UInt64>>;
                        };
                        seed: Option<Field>;
                        startCheckpoint: Option<Field>;
                        lockCheckpoint: Option<Field>;
                        epochLength: Option<Range<UInt32>>;
                    };
                    nextEpochData: {
                        ledger: {
                            hash: Option<Field>;
                            totalCurrency: Option<Range<UInt64>>;
                        };
                        seed: Option<Field>;
                        startCheckpoint: Option<Field>;
                        lockCheckpoint: Option<Field>;
                        epochLength: Option<Range<UInt32>>;
                    };
                };
                account: {
                    balance: Option<Range<UInt64>>;
                    nonce: Option<Range<UInt32>>;
                    receiptChainHash: Option<Field>;
                    delegate: Option<PublicKey>;
                    state: Option<Field>[];
                    actionState: Option<Field>;
                    provedState: Option<Bool>;
                    isNew: Option<Bool>;
                };
                validWhile: Option<Range<UInt32>>;
            };
            useFullCommitment: Bool;
            implicitAccountCreationFee: Bool;
            mayUseToken: {
                parentsOwnToken: Bool;
                inheritFromParent: Bool;
            };
            authorizationKind: {
                isSigned: Bool;
                isProved: Bool;
                verificationKeyHash: Field;
            };
        };
        authorization: {
            proof: string | undefined;
            signature: string | undefined;
        };
    }[];
    memo: string;
};
declare const ZkappCommand: BindingsType.Object<ZkappCommand>;
declare const Types: {
    [key: string]: BindingsType<any>;
};
