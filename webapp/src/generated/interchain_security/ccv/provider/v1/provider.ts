// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: interchain_security/ccv/provider/v1/provider.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Coin, DecCoin } from "../../../../cosmos/base/v1beta1/coin.js";
import { Equivocation } from "../../../../cosmos/evidence/v1beta1/evidence.js";
import { Duration } from "../../../../google/protobuf/duration.js";
import { Timestamp } from "../../../../google/protobuf/timestamp.js";
import { Height } from "../../../../ibc/core/client/v1/client.js";
import { ClientState } from "../../../../ibc/lightclients/tendermint/v1/tendermint.js";
import { PublicKey } from "../../../../tendermint/crypto/keys.js";
import { ValidatorSetChangePacketData } from "../../v1/wire.js";

export const protobufPackage = "interchain_security.ccv.provider.v1";

/**
 * ConsumerAdditionProposal is a governance proposal on the provider chain to
 * spawn a new consumer chain. If it passes, then all validators on the provider
 * chain are expected to validate the consumer chain at spawn time or get
 * slashed. It is recommended that spawn time occurs after the proposal end
 * time.
 * Use MsgConsumerAddition to submit this proposal type.
 */
export interface ConsumerAdditionProposal {
  /** the title of the proposal */
  title: string;
  /** the description of the proposal */
  description: string;
  /**
   * the proposed chain-id of the new consumer chain, must be different from all
   * other consumer chain ids of the executing provider chain.
   */
  chainId: string;
  /**
   * the proposed initial height of new consumer chain.
   * For a completely new chain, this will be {0,1}. However, it may be
   * different if this is a chain that is converting to a consumer chain.
   */
  initialHeight?:
    | Height
    | undefined;
  /**
   * The hash of the consumer chain genesis state without the consumer CCV
   * module genesis params. It is used for off-chain confirmation of
   * genesis.json validity by validators and other parties.
   */
  genesisHash: Uint8Array;
  /**
   * The hash of the consumer chain binary that should be run by validators on
   * chain initialization. It is used for off-chain confirmation of binary
   * validity by validators and other parties.
   */
  binaryHash: Uint8Array;
  /**
   * spawn time is the time on the provider chain at which the consumer chain
   * genesis is finalized and all validators will be responsible for starting
   * their consumer chain validator node.
   */
  spawnTime?:
    | Date
    | undefined;
  /**
   * Unbonding period for the consumer,
   * which should be smaller than that of the provider in general.
   */
  unbondingPeriod?:
    | Duration
    | undefined;
  /** Sent CCV related IBC packets will timeout after this duration */
  ccvTimeoutPeriod?:
    | Duration
    | undefined;
  /** Sent transfer related IBC packets will timeout after this duration */
  transferTimeoutPeriod?:
    | Duration
    | undefined;
  /**
   * The fraction of tokens allocated to the consumer redistribution address
   * during distribution events. The fraction is a string representing a
   * decimal number. For example "0.75" would represent 75%.
   */
  consumerRedistributionFraction: string;
  /**
   * BlocksPerDistributionTransmission is the number of blocks between
   * ibc-token-transfers from the consumer chain to the provider chain. On
   * sending transmission event, `consumer_redistribution_fraction` of the
   * accumulated tokens are sent to the consumer redistribution address.
   */
  blocksPerDistributionTransmission: string;
  /**
   * The number of historical info entries to persist in store.
   * This param is a part of the cosmos sdk staking module. In the case of
   * a ccv enabled consumer chain, the ccv module acts as the staking module.
   */
  historicalEntries: string;
  /**
   * The ID of a token transfer channel used for the Reward Distribution
   * sub-protocol. If DistributionTransmissionChannel == "", a new transfer
   * channel is created on top of the same connection as the CCV channel.
   * Note that transfer_channel_id is the ID of the channel end on the consumer
   * chain. it is most relevant for chains performing a sovereign to consumer
   * changeover in order to maintain the existing ibc transfer channel
   */
  distributionTransmissionChannel: string;
  /**
   * Corresponds to the percentage of validators that have to validate the chain under the Top N case.
   * For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power
   * have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100].
   * A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ [50, 100] as a Top N chain.
   */
  topN: number;
  /**
   * Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if
   * `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the
   * consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only
   * 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need
   * to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis.
   */
  validatorsPowerCap: number;
  /**
   * Corresponds to the maximum number of validators that can validate a consumer chain.
   * Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op.
   */
  validatorSetCap: number;
  /**
   * Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate
   * the consumer chain.
   */
  allowlist: string[];
  /** Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain. */
  denylist: string[];
}

/**
 * ConsumerRemovalProposal is a governance proposal on the provider chain to
 * remove (and stop) a consumer chain. If it passes, all the consumer chain's
 * state is removed from the provider chain. The outstanding unbonding operation
 * funds are released.
 * Use MsgConsumerRemoval to submit this proposal type.
 */
export interface ConsumerRemovalProposal {
  /** the title of the proposal */
  title: string;
  /** the description of the proposal */
  description: string;
  /** the chain-id of the consumer chain to be stopped */
  chainId: string;
  /**
   * the time on the provider chain at which all validators are responsible to
   * stop their consumer chain validator node
   */
  stopTime?: Date | undefined;
}

/**
 * ConsumerModificationProposal is a governance proposal on the provider chain to modify parameters of a running
 * consumer chain. If it passes, the consumer chain's state is updated to take into account the newest params.
 */
export interface ConsumerModificationProposal {
  /** the title of the proposal */
  title: string;
  /** the description of the proposal */
  description: string;
  /** the chain-id of the consumer chain to be modified */
  chainId: string;
  /**
   * Corresponds to the percentage of validators that have to validate the chain under the Top N case.
   * For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power
   * have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100].
   * A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ [50, 100] as a Top N chain.
   */
  topN: number;
  /**
   * Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if
   * `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the
   * consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only
   * 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need
   * to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis.
   */
  validatorsPowerCap: number;
  /**
   * Corresponds to the maximum number of validators that can validate a consumer chain.
   * Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op.
   */
  validatorSetCap: number;
  /**
   * Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate
   * the consumer chain.
   */
  allowlist: string[];
  /** Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain. */
  denylist: string[];
}

/**
 * EquivocationProposal is a governance proposal on the provider chain to
 * punish a validator for equivocation on a consumer chain.
 *
 * This type is only used internally to the consumer CCV module.
 * WARNING: This message is deprecated now that equivocations can be submitted
 * and verified automatically on the provider. (see SubmitConsumerDoubleVoting in proto/interchain-security/ccv/provider/v1/tx.proto).
 *
 * @deprecated
 */
export interface EquivocationProposal {
  /** the title of the proposal */
  title: string;
  /** the description of the proposal */
  description: string;
  /** the list of equivocations that will be processed */
  equivocations: Equivocation[];
}

/**
 * ChangeRewardDenomsProposal is a governance proposal on the provider chain to
 * mutate the set of denoms accepted by the provider as rewards.
 * Use MsgChangeRewardDenoms to submit this proposal type.
 */
export interface ChangeRewardDenomsProposal {
  /** the title of the proposal */
  title: string;
  /** the description of the proposal */
  description: string;
  /** the list of consumer reward denoms to add */
  denomsToAdd: string[];
  /** the list of consumer reward denoms to remove */
  denomsToRemove: string[];
}

/**
 * A persisted queue entry indicating that a slash packet data instance needs to
 * be handled. This type belongs in the "global" queue, to coordinate slash
 * packet handling times between consumers.
 */
export interface GlobalSlashEntry {
  /**
   * Block time that slash packet was received by provider chain.
   * This field is used for store key iteration ordering.
   */
  recvTime?:
    | Date
    | undefined;
  /** The consumer that sent a slash packet. */
  consumerChainId: string;
  /**
   * The IBC sequence number of the recv packet.
   * This field is used in the store key to ensure uniqueness.
   */
  ibcSeqNum: string;
  /**
   * The provider's consensus address of the validator being slashed.
   * This field is used to obtain validator power in HandleThrottleQueues.
   *
   * This field is not used in the store key, but is persisted in value bytes,
   * see QueueGlobalSlashEntry.
   */
  providerValConsAddr: Uint8Array;
}

/** Params defines the parameters for CCV Provider module */
export interface Params {
  templateClient?:
    | ClientState
    | undefined;
  /**
   * TrustingPeriodFraction is used to compute the consumer and provider IBC
   * client's TrustingPeriod from the chain defined UnbondingPeriod
   */
  trustingPeriodFraction: string;
  /** Sent IBC packets will timeout after this duration */
  ccvTimeoutPeriod?:
    | Duration
    | undefined;
  /**
   * The channel initialization (IBC channel opening handshake) will timeout
   * after this duration
   */
  initTimeoutPeriod?:
    | Duration
    | undefined;
  /**
   * The VSC packets sent by the provider will timeout after this duration.
   * Note that unlike ccv_timeout_period which is an IBC param,
   * the vsc_timeout_period is a provider-side param that enables the provider
   * to timeout VSC packets even when a consumer chain is not live.
   */
  vscTimeoutPeriod?:
    | Duration
    | undefined;
  /** The period for which the slash meter is replenished */
  slashMeterReplenishPeriod?:
    | Duration
    | undefined;
  /**
   * The fraction of total voting power that is replenished to the slash meter
   * every replenish period. This param also serves as a maximum fraction of
   * total voting power that the slash meter can hold.
   */
  slashMeterReplenishFraction: string;
  /** The fee required to be paid to add a reward denom */
  consumerRewardDenomRegistrationFee?:
    | Coin
    | undefined;
  /** The number of blocks that comprise an epoch. */
  blocksPerEpoch: string;
  /** The number of epochs a validator has to validate a consumer chain in order to start receiving rewards from that chain. */
  numberOfEpochsToStartReceivingRewards: string;
}

/**
 * SlashAcks contains cons addresses of consumer chain validators
 * successfully slashed on the provider chain.
 */
export interface SlashAcks {
  addresses: string[];
}

/**
 * ConsumerAdditionProposals holds pending governance proposals on the provider
 * chain to spawn a new chain.
 */
export interface ConsumerAdditionProposals {
  /** proposals waiting for spawn_time to pass */
  pending: ConsumerAdditionProposal[];
}

/**
 * ConsumerRemovalProposals holds pending governance proposals on the provider
 * chain to remove (and stop) a consumer chain.
 */
export interface ConsumerRemovalProposals {
  /** proposals waiting for stop_time to pass */
  pending: ConsumerRemovalProposal[];
}

/** AddressList contains a list of consensus addresses */
export interface AddressList {
  addresses: Uint8Array[];
}

/** ChannelToChain is used to map a CCV channel ID to the consumer chainID */
export interface ChannelToChain {
  channelId: string;
  chainId: string;
}

/**
 * VscUnbondingOps contains the IDs of unbonding operations that are waiting for
 * at least one VSCMaturedPacket with vscID from a consumer chain
 */
export interface VscUnbondingOps {
  vscId: string;
  unbondingOpIds: string[];
}

/**
 * UnbondingOp contains the ids of consumer chains that need to unbond before
 * the unbonding operation with the given ID can unbond
 */
export interface UnbondingOp {
  id: string;
  /** consumer chains that are still unbonding */
  unbondingConsumerChains: string[];
}

export interface InitTimeoutTimestamp {
  chainId: string;
  timestamp: string;
}

export interface VscSendTimestamp {
  vscId: string;
  timestamp?: Date | undefined;
}

/** ValidatorSetChangePackets is a pb list of ccv.ValidatorSetChangePacketData. */
export interface ValidatorSetChangePackets {
  list: ValidatorSetChangePacketData[];
}

/**
 * MaturedUnbondingOps defines a list of ids corresponding to ids of matured
 * unbonding operations.
 */
export interface MaturedUnbondingOps {
  ids: string[];
}

/** ExportedVscSendTimestamps is VscSendTimestamp with chainID info for exporting to genesis */
export interface ExportedVscSendTimestamp {
  chainId: string;
  vscSendTimestamps: VscSendTimestamp[];
}

export interface KeyAssignmentReplacement {
  providerAddr: Uint8Array;
  prevCKey?: PublicKey | undefined;
  power: string;
}

/**
 * Used to serialize the ValidatorConsumerPubKey index from key assignment
 * ValidatorConsumerPubKey: (chainID, providerAddr consAddr) -> consumerKey
 * tmprotocrypto.PublicKey
 */
export interface ValidatorConsumerPubKey {
  chainId: string;
  providerAddr: Uint8Array;
  consumerKey?: PublicKey | undefined;
}

/**
 * Used to serialize the ValidatorConsumerAddr index from key assignment
 * ValidatorByConsumerAddr: (chainID, consumerAddr consAddr) -> providerAddr
 * consAddr
 */
export interface ValidatorByConsumerAddr {
  chainId: string;
  consumerAddr: Uint8Array;
  providerAddr: Uint8Array;
}

/**
 * Used to serialize the ConsumerAddrsToPrune index from key assignment
 * ConsumerAddrsToPrune: (chainID, vscID uint64) -> consumerAddrs AddressList
 */
export interface ConsumerAddrsToPrune {
  chainId: string;
  vscId: string;
  consumerAddrs?: AddressList | undefined;
}

/**
 * ConsumerValidator is used to facilitate epoch-based transitions. It contains relevant info for
 * a validator that is expected to validate on a consumer chain during an epoch.
 */
export interface ConsumerValidator {
  /** validator's consensus address on the provider chain */
  providerConsAddr: Uint8Array;
  /** voting power the validator has during this epoch */
  power: string;
  /** public key the validator uses on the consumer chain during this epoch */
  consumerPublicKey?:
    | PublicKey
    | undefined;
  /**
   * height the validator had when it FIRST became a consumer validator
   * If a validator becomes a consumer validator at height `H` and is continuously a consumer validator for all the upcoming
   * epochs, then the height of the validator SHOULD remain `H`. This height only resets to a different height if a validator
   * stops being a consumer validator during an epoch and later becomes again a consumer validator.
   */
  joinHeight: string;
}

/**
 * ConsumerRewardsAllocation stores the rewards allocated by a consumer chain
 * to the consumer rewards pool. It is used to allocate the tokens to the consumer
 * opted-in validators and the community pool during BeginBlock.
 */
export interface ConsumerRewardsAllocation {
  rewards: DecCoin[];
}

function createBaseConsumerAdditionProposal(): ConsumerAdditionProposal {
  return {
    title: "",
    description: "",
    chainId: "",
    initialHeight: undefined,
    genesisHash: new Uint8Array(0),
    binaryHash: new Uint8Array(0),
    spawnTime: undefined,
    unbondingPeriod: undefined,
    ccvTimeoutPeriod: undefined,
    transferTimeoutPeriod: undefined,
    consumerRedistributionFraction: "",
    blocksPerDistributionTransmission: "0",
    historicalEntries: "0",
    distributionTransmissionChannel: "",
    topN: 0,
    validatorsPowerCap: 0,
    validatorSetCap: 0,
    allowlist: [],
    denylist: [],
  };
}

export const ConsumerAdditionProposal: MessageFns<ConsumerAdditionProposal> = {
  encode(message: ConsumerAdditionProposal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.initialHeight !== undefined) {
      Height.encode(message.initialHeight, writer.uint32(34).fork()).join();
    }
    if (message.genesisHash.length !== 0) {
      writer.uint32(42).bytes(message.genesisHash);
    }
    if (message.binaryHash.length !== 0) {
      writer.uint32(50).bytes(message.binaryHash);
    }
    if (message.spawnTime !== undefined) {
      Timestamp.encode(toTimestamp(message.spawnTime), writer.uint32(58).fork()).join();
    }
    if (message.unbondingPeriod !== undefined) {
      Duration.encode(message.unbondingPeriod, writer.uint32(66).fork()).join();
    }
    if (message.ccvTimeoutPeriod !== undefined) {
      Duration.encode(message.ccvTimeoutPeriod, writer.uint32(74).fork()).join();
    }
    if (message.transferTimeoutPeriod !== undefined) {
      Duration.encode(message.transferTimeoutPeriod, writer.uint32(82).fork()).join();
    }
    if (message.consumerRedistributionFraction !== "") {
      writer.uint32(90).string(message.consumerRedistributionFraction);
    }
    if (message.blocksPerDistributionTransmission !== "0") {
      writer.uint32(96).int64(message.blocksPerDistributionTransmission);
    }
    if (message.historicalEntries !== "0") {
      writer.uint32(104).int64(message.historicalEntries);
    }
    if (message.distributionTransmissionChannel !== "") {
      writer.uint32(114).string(message.distributionTransmissionChannel);
    }
    if (message.topN !== 0) {
      writer.uint32(120).uint32(message.topN);
    }
    if (message.validatorsPowerCap !== 0) {
      writer.uint32(128).uint32(message.validatorsPowerCap);
    }
    if (message.validatorSetCap !== 0) {
      writer.uint32(136).uint32(message.validatorSetCap);
    }
    for (const v of message.allowlist) {
      writer.uint32(146).string(v!);
    }
    for (const v of message.denylist) {
      writer.uint32(154).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumerAdditionProposal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumerAdditionProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.initialHeight = Height.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.genesisHash = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.binaryHash = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.spawnTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.unbondingPeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ccvTimeoutPeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.transferTimeoutPeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.consumerRedistributionFraction = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.blocksPerDistributionTransmission = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.historicalEntries = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.distributionTransmissionChannel = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.topN = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.validatorsPowerCap = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.validatorSetCap = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.allowlist.push(reader.string());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.denylist.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumerAdditionProposal {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      initialHeight: isSet(object.initialHeight) ? Height.fromJSON(object.initialHeight) : undefined,
      genesisHash: isSet(object.genesisHash) ? bytesFromBase64(object.genesisHash) : new Uint8Array(0),
      binaryHash: isSet(object.binaryHash) ? bytesFromBase64(object.binaryHash) : new Uint8Array(0),
      spawnTime: isSet(object.spawnTime) ? fromJsonTimestamp(object.spawnTime) : undefined,
      unbondingPeriod: isSet(object.unbondingPeriod) ? Duration.fromJSON(object.unbondingPeriod) : undefined,
      ccvTimeoutPeriod: isSet(object.ccvTimeoutPeriod) ? Duration.fromJSON(object.ccvTimeoutPeriod) : undefined,
      transferTimeoutPeriod: isSet(object.transferTimeoutPeriod)
        ? Duration.fromJSON(object.transferTimeoutPeriod)
        : undefined,
      consumerRedistributionFraction: isSet(object.consumerRedistributionFraction)
        ? globalThis.String(object.consumerRedistributionFraction)
        : "",
      blocksPerDistributionTransmission: isSet(object.blocksPerDistributionTransmission)
        ? globalThis.String(object.blocksPerDistributionTransmission)
        : "0",
      historicalEntries: isSet(object.historicalEntries) ? globalThis.String(object.historicalEntries) : "0",
      distributionTransmissionChannel: isSet(object.distributionTransmissionChannel)
        ? globalThis.String(object.distributionTransmissionChannel)
        : "",
      topN: isSet(object.topN) ? globalThis.Number(object.topN) : 0,
      validatorsPowerCap: isSet(object.validatorsPowerCap) ? globalThis.Number(object.validatorsPowerCap) : 0,
      validatorSetCap: isSet(object.validatorSetCap) ? globalThis.Number(object.validatorSetCap) : 0,
      allowlist: globalThis.Array.isArray(object?.allowlist)
        ? object.allowlist.map((e: any) => globalThis.String(e))
        : [],
      denylist: globalThis.Array.isArray(object?.denylist) ? object.denylist.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ConsumerAdditionProposal): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.initialHeight !== undefined) {
      obj.initialHeight = Height.toJSON(message.initialHeight);
    }
    if (message.genesisHash.length !== 0) {
      obj.genesisHash = base64FromBytes(message.genesisHash);
    }
    if (message.binaryHash.length !== 0) {
      obj.binaryHash = base64FromBytes(message.binaryHash);
    }
    if (message.spawnTime !== undefined) {
      obj.spawnTime = message.spawnTime.toISOString();
    }
    if (message.unbondingPeriod !== undefined) {
      obj.unbondingPeriod = Duration.toJSON(message.unbondingPeriod);
    }
    if (message.ccvTimeoutPeriod !== undefined) {
      obj.ccvTimeoutPeriod = Duration.toJSON(message.ccvTimeoutPeriod);
    }
    if (message.transferTimeoutPeriod !== undefined) {
      obj.transferTimeoutPeriod = Duration.toJSON(message.transferTimeoutPeriod);
    }
    if (message.consumerRedistributionFraction !== "") {
      obj.consumerRedistributionFraction = message.consumerRedistributionFraction;
    }
    if (message.blocksPerDistributionTransmission !== "0") {
      obj.blocksPerDistributionTransmission = message.blocksPerDistributionTransmission;
    }
    if (message.historicalEntries !== "0") {
      obj.historicalEntries = message.historicalEntries;
    }
    if (message.distributionTransmissionChannel !== "") {
      obj.distributionTransmissionChannel = message.distributionTransmissionChannel;
    }
    if (message.topN !== 0) {
      obj.topN = Math.round(message.topN);
    }
    if (message.validatorsPowerCap !== 0) {
      obj.validatorsPowerCap = Math.round(message.validatorsPowerCap);
    }
    if (message.validatorSetCap !== 0) {
      obj.validatorSetCap = Math.round(message.validatorSetCap);
    }
    if (message.allowlist?.length) {
      obj.allowlist = message.allowlist;
    }
    if (message.denylist?.length) {
      obj.denylist = message.denylist;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumerAdditionProposal>, I>>(base?: I): ConsumerAdditionProposal {
    return ConsumerAdditionProposal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumerAdditionProposal>, I>>(object: I): ConsumerAdditionProposal {
    const message = createBaseConsumerAdditionProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.chainId = object.chainId ?? "";
    message.initialHeight = (object.initialHeight !== undefined && object.initialHeight !== null)
      ? Height.fromPartial(object.initialHeight)
      : undefined;
    message.genesisHash = object.genesisHash ?? new Uint8Array(0);
    message.binaryHash = object.binaryHash ?? new Uint8Array(0);
    message.spawnTime = object.spawnTime ?? undefined;
    message.unbondingPeriod = (object.unbondingPeriod !== undefined && object.unbondingPeriod !== null)
      ? Duration.fromPartial(object.unbondingPeriod)
      : undefined;
    message.ccvTimeoutPeriod = (object.ccvTimeoutPeriod !== undefined && object.ccvTimeoutPeriod !== null)
      ? Duration.fromPartial(object.ccvTimeoutPeriod)
      : undefined;
    message.transferTimeoutPeriod =
      (object.transferTimeoutPeriod !== undefined && object.transferTimeoutPeriod !== null)
        ? Duration.fromPartial(object.transferTimeoutPeriod)
        : undefined;
    message.consumerRedistributionFraction = object.consumerRedistributionFraction ?? "";
    message.blocksPerDistributionTransmission = object.blocksPerDistributionTransmission ?? "0";
    message.historicalEntries = object.historicalEntries ?? "0";
    message.distributionTransmissionChannel = object.distributionTransmissionChannel ?? "";
    message.topN = object.topN ?? 0;
    message.validatorsPowerCap = object.validatorsPowerCap ?? 0;
    message.validatorSetCap = object.validatorSetCap ?? 0;
    message.allowlist = object.allowlist?.map((e) => e) || [];
    message.denylist = object.denylist?.map((e) => e) || [];
    return message;
  },
};

function createBaseConsumerRemovalProposal(): ConsumerRemovalProposal {
  return { title: "", description: "", chainId: "", stopTime: undefined };
}

export const ConsumerRemovalProposal: MessageFns<ConsumerRemovalProposal> = {
  encode(message: ConsumerRemovalProposal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.stopTime !== undefined) {
      Timestamp.encode(toTimestamp(message.stopTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumerRemovalProposal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumerRemovalProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stopTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumerRemovalProposal {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      stopTime: isSet(object.stopTime) ? fromJsonTimestamp(object.stopTime) : undefined,
    };
  },

  toJSON(message: ConsumerRemovalProposal): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.stopTime !== undefined) {
      obj.stopTime = message.stopTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumerRemovalProposal>, I>>(base?: I): ConsumerRemovalProposal {
    return ConsumerRemovalProposal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumerRemovalProposal>, I>>(object: I): ConsumerRemovalProposal {
    const message = createBaseConsumerRemovalProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.chainId = object.chainId ?? "";
    message.stopTime = object.stopTime ?? undefined;
    return message;
  },
};

function createBaseConsumerModificationProposal(): ConsumerModificationProposal {
  return {
    title: "",
    description: "",
    chainId: "",
    topN: 0,
    validatorsPowerCap: 0,
    validatorSetCap: 0,
    allowlist: [],
    denylist: [],
  };
}

export const ConsumerModificationProposal: MessageFns<ConsumerModificationProposal> = {
  encode(message: ConsumerModificationProposal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.topN !== 0) {
      writer.uint32(32).uint32(message.topN);
    }
    if (message.validatorsPowerCap !== 0) {
      writer.uint32(40).uint32(message.validatorsPowerCap);
    }
    if (message.validatorSetCap !== 0) {
      writer.uint32(48).uint32(message.validatorSetCap);
    }
    for (const v of message.allowlist) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.denylist) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumerModificationProposal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumerModificationProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.topN = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.validatorsPowerCap = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.validatorSetCap = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.allowlist.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.denylist.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumerModificationProposal {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      topN: isSet(object.topN) ? globalThis.Number(object.topN) : 0,
      validatorsPowerCap: isSet(object.validatorsPowerCap) ? globalThis.Number(object.validatorsPowerCap) : 0,
      validatorSetCap: isSet(object.validatorSetCap) ? globalThis.Number(object.validatorSetCap) : 0,
      allowlist: globalThis.Array.isArray(object?.allowlist)
        ? object.allowlist.map((e: any) => globalThis.String(e))
        : [],
      denylist: globalThis.Array.isArray(object?.denylist) ? object.denylist.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ConsumerModificationProposal): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.topN !== 0) {
      obj.topN = Math.round(message.topN);
    }
    if (message.validatorsPowerCap !== 0) {
      obj.validatorsPowerCap = Math.round(message.validatorsPowerCap);
    }
    if (message.validatorSetCap !== 0) {
      obj.validatorSetCap = Math.round(message.validatorSetCap);
    }
    if (message.allowlist?.length) {
      obj.allowlist = message.allowlist;
    }
    if (message.denylist?.length) {
      obj.denylist = message.denylist;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumerModificationProposal>, I>>(base?: I): ConsumerModificationProposal {
    return ConsumerModificationProposal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumerModificationProposal>, I>>(object: I): ConsumerModificationProposal {
    const message = createBaseConsumerModificationProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.chainId = object.chainId ?? "";
    message.topN = object.topN ?? 0;
    message.validatorsPowerCap = object.validatorsPowerCap ?? 0;
    message.validatorSetCap = object.validatorSetCap ?? 0;
    message.allowlist = object.allowlist?.map((e) => e) || [];
    message.denylist = object.denylist?.map((e) => e) || [];
    return message;
  },
};

function createBaseEquivocationProposal(): EquivocationProposal {
  return { title: "", description: "", equivocations: [] };
}

export const EquivocationProposal: MessageFns<EquivocationProposal> = {
  encode(message: EquivocationProposal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.equivocations) {
      Equivocation.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EquivocationProposal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEquivocationProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.equivocations.push(Equivocation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EquivocationProposal {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      equivocations: globalThis.Array.isArray(object?.equivocations)
        ? object.equivocations.map((e: any) => Equivocation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EquivocationProposal): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.equivocations?.length) {
      obj.equivocations = message.equivocations.map((e) => Equivocation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EquivocationProposal>, I>>(base?: I): EquivocationProposal {
    return EquivocationProposal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EquivocationProposal>, I>>(object: I): EquivocationProposal {
    const message = createBaseEquivocationProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.equivocations = object.equivocations?.map((e) => Equivocation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChangeRewardDenomsProposal(): ChangeRewardDenomsProposal {
  return { title: "", description: "", denomsToAdd: [], denomsToRemove: [] };
}

export const ChangeRewardDenomsProposal: MessageFns<ChangeRewardDenomsProposal> = {
  encode(message: ChangeRewardDenomsProposal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.denomsToAdd) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.denomsToRemove) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeRewardDenomsProposal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeRewardDenomsProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.denomsToAdd.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.denomsToRemove.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeRewardDenomsProposal {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      denomsToAdd: globalThis.Array.isArray(object?.denomsToAdd)
        ? object.denomsToAdd.map((e: any) => globalThis.String(e))
        : [],
      denomsToRemove: globalThis.Array.isArray(object?.denomsToRemove)
        ? object.denomsToRemove.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ChangeRewardDenomsProposal): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.denomsToAdd?.length) {
      obj.denomsToAdd = message.denomsToAdd;
    }
    if (message.denomsToRemove?.length) {
      obj.denomsToRemove = message.denomsToRemove;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangeRewardDenomsProposal>, I>>(base?: I): ChangeRewardDenomsProposal {
    return ChangeRewardDenomsProposal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangeRewardDenomsProposal>, I>>(object: I): ChangeRewardDenomsProposal {
    const message = createBaseChangeRewardDenomsProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.denomsToAdd = object.denomsToAdd?.map((e) => e) || [];
    message.denomsToRemove = object.denomsToRemove?.map((e) => e) || [];
    return message;
  },
};

function createBaseGlobalSlashEntry(): GlobalSlashEntry {
  return { recvTime: undefined, consumerChainId: "", ibcSeqNum: "0", providerValConsAddr: new Uint8Array(0) };
}

export const GlobalSlashEntry: MessageFns<GlobalSlashEntry> = {
  encode(message: GlobalSlashEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recvTime !== undefined) {
      Timestamp.encode(toTimestamp(message.recvTime), writer.uint32(10).fork()).join();
    }
    if (message.consumerChainId !== "") {
      writer.uint32(18).string(message.consumerChainId);
    }
    if (message.ibcSeqNum !== "0") {
      writer.uint32(24).uint64(message.ibcSeqNum);
    }
    if (message.providerValConsAddr.length !== 0) {
      writer.uint32(34).bytes(message.providerValConsAddr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GlobalSlashEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGlobalSlashEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recvTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.consumerChainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.ibcSeqNum = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.providerValConsAddr = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GlobalSlashEntry {
    return {
      recvTime: isSet(object.recvTime) ? fromJsonTimestamp(object.recvTime) : undefined,
      consumerChainId: isSet(object.consumerChainId) ? globalThis.String(object.consumerChainId) : "",
      ibcSeqNum: isSet(object.ibcSeqNum) ? globalThis.String(object.ibcSeqNum) : "0",
      providerValConsAddr: isSet(object.providerValConsAddr)
        ? bytesFromBase64(object.providerValConsAddr)
        : new Uint8Array(0),
    };
  },

  toJSON(message: GlobalSlashEntry): unknown {
    const obj: any = {};
    if (message.recvTime !== undefined) {
      obj.recvTime = message.recvTime.toISOString();
    }
    if (message.consumerChainId !== "") {
      obj.consumerChainId = message.consumerChainId;
    }
    if (message.ibcSeqNum !== "0") {
      obj.ibcSeqNum = message.ibcSeqNum;
    }
    if (message.providerValConsAddr.length !== 0) {
      obj.providerValConsAddr = base64FromBytes(message.providerValConsAddr);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GlobalSlashEntry>, I>>(base?: I): GlobalSlashEntry {
    return GlobalSlashEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GlobalSlashEntry>, I>>(object: I): GlobalSlashEntry {
    const message = createBaseGlobalSlashEntry();
    message.recvTime = object.recvTime ?? undefined;
    message.consumerChainId = object.consumerChainId ?? "";
    message.ibcSeqNum = object.ibcSeqNum ?? "0";
    message.providerValConsAddr = object.providerValConsAddr ?? new Uint8Array(0);
    return message;
  },
};

function createBaseParams(): Params {
  return {
    templateClient: undefined,
    trustingPeriodFraction: "",
    ccvTimeoutPeriod: undefined,
    initTimeoutPeriod: undefined,
    vscTimeoutPeriod: undefined,
    slashMeterReplenishPeriod: undefined,
    slashMeterReplenishFraction: "",
    consumerRewardDenomRegistrationFee: undefined,
    blocksPerEpoch: "0",
    numberOfEpochsToStartReceivingRewards: "0",
  };
}

export const Params: MessageFns<Params> = {
  encode(message: Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.templateClient !== undefined) {
      ClientState.encode(message.templateClient, writer.uint32(10).fork()).join();
    }
    if (message.trustingPeriodFraction !== "") {
      writer.uint32(18).string(message.trustingPeriodFraction);
    }
    if (message.ccvTimeoutPeriod !== undefined) {
      Duration.encode(message.ccvTimeoutPeriod, writer.uint32(26).fork()).join();
    }
    if (message.initTimeoutPeriod !== undefined) {
      Duration.encode(message.initTimeoutPeriod, writer.uint32(34).fork()).join();
    }
    if (message.vscTimeoutPeriod !== undefined) {
      Duration.encode(message.vscTimeoutPeriod, writer.uint32(42).fork()).join();
    }
    if (message.slashMeterReplenishPeriod !== undefined) {
      Duration.encode(message.slashMeterReplenishPeriod, writer.uint32(50).fork()).join();
    }
    if (message.slashMeterReplenishFraction !== "") {
      writer.uint32(58).string(message.slashMeterReplenishFraction);
    }
    if (message.consumerRewardDenomRegistrationFee !== undefined) {
      Coin.encode(message.consumerRewardDenomRegistrationFee, writer.uint32(74).fork()).join();
    }
    if (message.blocksPerEpoch !== "0") {
      writer.uint32(80).int64(message.blocksPerEpoch);
    }
    if (message.numberOfEpochsToStartReceivingRewards !== "0") {
      writer.uint32(88).int64(message.numberOfEpochsToStartReceivingRewards);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.templateClient = ClientState.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trustingPeriodFraction = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ccvTimeoutPeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.initTimeoutPeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.vscTimeoutPeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.slashMeterReplenishPeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.slashMeterReplenishFraction = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.consumerRewardDenomRegistrationFee = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.blocksPerEpoch = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.numberOfEpochsToStartReceivingRewards = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      templateClient: isSet(object.templateClient) ? ClientState.fromJSON(object.templateClient) : undefined,
      trustingPeriodFraction: isSet(object.trustingPeriodFraction)
        ? globalThis.String(object.trustingPeriodFraction)
        : "",
      ccvTimeoutPeriod: isSet(object.ccvTimeoutPeriod) ? Duration.fromJSON(object.ccvTimeoutPeriod) : undefined,
      initTimeoutPeriod: isSet(object.initTimeoutPeriod) ? Duration.fromJSON(object.initTimeoutPeriod) : undefined,
      vscTimeoutPeriod: isSet(object.vscTimeoutPeriod) ? Duration.fromJSON(object.vscTimeoutPeriod) : undefined,
      slashMeterReplenishPeriod: isSet(object.slashMeterReplenishPeriod)
        ? Duration.fromJSON(object.slashMeterReplenishPeriod)
        : undefined,
      slashMeterReplenishFraction: isSet(object.slashMeterReplenishFraction)
        ? globalThis.String(object.slashMeterReplenishFraction)
        : "",
      consumerRewardDenomRegistrationFee: isSet(object.consumerRewardDenomRegistrationFee)
        ? Coin.fromJSON(object.consumerRewardDenomRegistrationFee)
        : undefined,
      blocksPerEpoch: isSet(object.blocksPerEpoch) ? globalThis.String(object.blocksPerEpoch) : "0",
      numberOfEpochsToStartReceivingRewards: isSet(object.numberOfEpochsToStartReceivingRewards)
        ? globalThis.String(object.numberOfEpochsToStartReceivingRewards)
        : "0",
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    if (message.templateClient !== undefined) {
      obj.templateClient = ClientState.toJSON(message.templateClient);
    }
    if (message.trustingPeriodFraction !== "") {
      obj.trustingPeriodFraction = message.trustingPeriodFraction;
    }
    if (message.ccvTimeoutPeriod !== undefined) {
      obj.ccvTimeoutPeriod = Duration.toJSON(message.ccvTimeoutPeriod);
    }
    if (message.initTimeoutPeriod !== undefined) {
      obj.initTimeoutPeriod = Duration.toJSON(message.initTimeoutPeriod);
    }
    if (message.vscTimeoutPeriod !== undefined) {
      obj.vscTimeoutPeriod = Duration.toJSON(message.vscTimeoutPeriod);
    }
    if (message.slashMeterReplenishPeriod !== undefined) {
      obj.slashMeterReplenishPeriod = Duration.toJSON(message.slashMeterReplenishPeriod);
    }
    if (message.slashMeterReplenishFraction !== "") {
      obj.slashMeterReplenishFraction = message.slashMeterReplenishFraction;
    }
    if (message.consumerRewardDenomRegistrationFee !== undefined) {
      obj.consumerRewardDenomRegistrationFee = Coin.toJSON(message.consumerRewardDenomRegistrationFee);
    }
    if (message.blocksPerEpoch !== "0") {
      obj.blocksPerEpoch = message.blocksPerEpoch;
    }
    if (message.numberOfEpochsToStartReceivingRewards !== "0") {
      obj.numberOfEpochsToStartReceivingRewards = message.numberOfEpochsToStartReceivingRewards;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Params>, I>>(base?: I): Params {
    return Params.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Params>, I>>(object: I): Params {
    const message = createBaseParams();
    message.templateClient = (object.templateClient !== undefined && object.templateClient !== null)
      ? ClientState.fromPartial(object.templateClient)
      : undefined;
    message.trustingPeriodFraction = object.trustingPeriodFraction ?? "";
    message.ccvTimeoutPeriod = (object.ccvTimeoutPeriod !== undefined && object.ccvTimeoutPeriod !== null)
      ? Duration.fromPartial(object.ccvTimeoutPeriod)
      : undefined;
    message.initTimeoutPeriod = (object.initTimeoutPeriod !== undefined && object.initTimeoutPeriod !== null)
      ? Duration.fromPartial(object.initTimeoutPeriod)
      : undefined;
    message.vscTimeoutPeriod = (object.vscTimeoutPeriod !== undefined && object.vscTimeoutPeriod !== null)
      ? Duration.fromPartial(object.vscTimeoutPeriod)
      : undefined;
    message.slashMeterReplenishPeriod =
      (object.slashMeterReplenishPeriod !== undefined && object.slashMeterReplenishPeriod !== null)
        ? Duration.fromPartial(object.slashMeterReplenishPeriod)
        : undefined;
    message.slashMeterReplenishFraction = object.slashMeterReplenishFraction ?? "";
    message.consumerRewardDenomRegistrationFee =
      (object.consumerRewardDenomRegistrationFee !== undefined && object.consumerRewardDenomRegistrationFee !== null)
        ? Coin.fromPartial(object.consumerRewardDenomRegistrationFee)
        : undefined;
    message.blocksPerEpoch = object.blocksPerEpoch ?? "0";
    message.numberOfEpochsToStartReceivingRewards = object.numberOfEpochsToStartReceivingRewards ?? "0";
    return message;
  },
};

function createBaseSlashAcks(): SlashAcks {
  return { addresses: [] };
}

export const SlashAcks: MessageFns<SlashAcks> = {
  encode(message: SlashAcks, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.addresses) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlashAcks {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlashAcks();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addresses.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlashAcks {
    return {
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SlashAcks): unknown {
    const obj: any = {};
    if (message.addresses?.length) {
      obj.addresses = message.addresses;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SlashAcks>, I>>(base?: I): SlashAcks {
    return SlashAcks.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SlashAcks>, I>>(object: I): SlashAcks {
    const message = createBaseSlashAcks();
    message.addresses = object.addresses?.map((e) => e) || [];
    return message;
  },
};

function createBaseConsumerAdditionProposals(): ConsumerAdditionProposals {
  return { pending: [] };
}

export const ConsumerAdditionProposals: MessageFns<ConsumerAdditionProposals> = {
  encode(message: ConsumerAdditionProposals, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pending) {
      ConsumerAdditionProposal.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumerAdditionProposals {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumerAdditionProposals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pending.push(ConsumerAdditionProposal.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumerAdditionProposals {
    return {
      pending: globalThis.Array.isArray(object?.pending)
        ? object.pending.map((e: any) => ConsumerAdditionProposal.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ConsumerAdditionProposals): unknown {
    const obj: any = {};
    if (message.pending?.length) {
      obj.pending = message.pending.map((e) => ConsumerAdditionProposal.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumerAdditionProposals>, I>>(base?: I): ConsumerAdditionProposals {
    return ConsumerAdditionProposals.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumerAdditionProposals>, I>>(object: I): ConsumerAdditionProposals {
    const message = createBaseConsumerAdditionProposals();
    message.pending = object.pending?.map((e) => ConsumerAdditionProposal.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConsumerRemovalProposals(): ConsumerRemovalProposals {
  return { pending: [] };
}

export const ConsumerRemovalProposals: MessageFns<ConsumerRemovalProposals> = {
  encode(message: ConsumerRemovalProposals, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pending) {
      ConsumerRemovalProposal.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumerRemovalProposals {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumerRemovalProposals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pending.push(ConsumerRemovalProposal.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumerRemovalProposals {
    return {
      pending: globalThis.Array.isArray(object?.pending)
        ? object.pending.map((e: any) => ConsumerRemovalProposal.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ConsumerRemovalProposals): unknown {
    const obj: any = {};
    if (message.pending?.length) {
      obj.pending = message.pending.map((e) => ConsumerRemovalProposal.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumerRemovalProposals>, I>>(base?: I): ConsumerRemovalProposals {
    return ConsumerRemovalProposals.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumerRemovalProposals>, I>>(object: I): ConsumerRemovalProposals {
    const message = createBaseConsumerRemovalProposals();
    message.pending = object.pending?.map((e) => ConsumerRemovalProposal.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddressList(): AddressList {
  return { addresses: [] };
}

export const AddressList: MessageFns<AddressList> = {
  encode(message: AddressList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.addresses) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddressList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addresses.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressList {
    return {
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: AddressList): unknown {
    const obj: any = {};
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddressList>, I>>(base?: I): AddressList {
    return AddressList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddressList>, I>>(object: I): AddressList {
    const message = createBaseAddressList();
    message.addresses = object.addresses?.map((e) => e) || [];
    return message;
  },
};

function createBaseChannelToChain(): ChannelToChain {
  return { channelId: "", chainId: "" };
}

export const ChannelToChain: MessageFns<ChannelToChain> = {
  encode(message: ChannelToChain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChannelToChain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelToChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelToChain {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
    };
  },

  toJSON(message: ChannelToChain): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelToChain>, I>>(base?: I): ChannelToChain {
    return ChannelToChain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelToChain>, I>>(object: I): ChannelToChain {
    const message = createBaseChannelToChain();
    message.channelId = object.channelId ?? "";
    message.chainId = object.chainId ?? "";
    return message;
  },
};

function createBaseVscUnbondingOps(): VscUnbondingOps {
  return { vscId: "0", unbondingOpIds: [] };
}

export const VscUnbondingOps: MessageFns<VscUnbondingOps> = {
  encode(message: VscUnbondingOps, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vscId !== "0") {
      writer.uint32(8).uint64(message.vscId);
    }
    writer.uint32(18).fork();
    for (const v of message.unbondingOpIds) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VscUnbondingOps {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVscUnbondingOps();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.vscId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.unbondingOpIds.push(reader.uint64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.unbondingOpIds.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VscUnbondingOps {
    return {
      vscId: isSet(object.vscId) ? globalThis.String(object.vscId) : "0",
      unbondingOpIds: globalThis.Array.isArray(object?.unbondingOpIds)
        ? object.unbondingOpIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: VscUnbondingOps): unknown {
    const obj: any = {};
    if (message.vscId !== "0") {
      obj.vscId = message.vscId;
    }
    if (message.unbondingOpIds?.length) {
      obj.unbondingOpIds = message.unbondingOpIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VscUnbondingOps>, I>>(base?: I): VscUnbondingOps {
    return VscUnbondingOps.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VscUnbondingOps>, I>>(object: I): VscUnbondingOps {
    const message = createBaseVscUnbondingOps();
    message.vscId = object.vscId ?? "0";
    message.unbondingOpIds = object.unbondingOpIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseUnbondingOp(): UnbondingOp {
  return { id: "0", unbondingConsumerChains: [] };
}

export const UnbondingOp: MessageFns<UnbondingOp> = {
  encode(message: UnbondingOp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).uint64(message.id);
    }
    for (const v of message.unbondingConsumerChains) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnbondingOp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnbondingOp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.unbondingConsumerChains.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnbondingOp {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
      unbondingConsumerChains: globalThis.Array.isArray(object?.unbondingConsumerChains)
        ? object.unbondingConsumerChains.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: UnbondingOp): unknown {
    const obj: any = {};
    if (message.id !== "0") {
      obj.id = message.id;
    }
    if (message.unbondingConsumerChains?.length) {
      obj.unbondingConsumerChains = message.unbondingConsumerChains;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnbondingOp>, I>>(base?: I): UnbondingOp {
    return UnbondingOp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnbondingOp>, I>>(object: I): UnbondingOp {
    const message = createBaseUnbondingOp();
    message.id = object.id ?? "0";
    message.unbondingConsumerChains = object.unbondingConsumerChains?.map((e) => e) || [];
    return message;
  },
};

function createBaseInitTimeoutTimestamp(): InitTimeoutTimestamp {
  return { chainId: "", timestamp: "0" };
}

export const InitTimeoutTimestamp: MessageFns<InitTimeoutTimestamp> = {
  encode(message: InitTimeoutTimestamp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.timestamp !== "0") {
      writer.uint32(16).uint64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitTimeoutTimestamp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitTimeoutTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitTimeoutTimestamp {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0",
    };
  },

  toJSON(message: InitTimeoutTimestamp): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.timestamp !== "0") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitTimeoutTimestamp>, I>>(base?: I): InitTimeoutTimestamp {
    return InitTimeoutTimestamp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitTimeoutTimestamp>, I>>(object: I): InitTimeoutTimestamp {
    const message = createBaseInitTimeoutTimestamp();
    message.chainId = object.chainId ?? "";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseVscSendTimestamp(): VscSendTimestamp {
  return { vscId: "0", timestamp: undefined };
}

export const VscSendTimestamp: MessageFns<VscSendTimestamp> = {
  encode(message: VscSendTimestamp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vscId !== "0") {
      writer.uint32(8).uint64(message.vscId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VscSendTimestamp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVscSendTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.vscId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VscSendTimestamp {
    return {
      vscId: isSet(object.vscId) ? globalThis.String(object.vscId) : "0",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: VscSendTimestamp): unknown {
    const obj: any = {};
    if (message.vscId !== "0") {
      obj.vscId = message.vscId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VscSendTimestamp>, I>>(base?: I): VscSendTimestamp {
    return VscSendTimestamp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VscSendTimestamp>, I>>(object: I): VscSendTimestamp {
    const message = createBaseVscSendTimestamp();
    message.vscId = object.vscId ?? "0";
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBaseValidatorSetChangePackets(): ValidatorSetChangePackets {
  return { list: [] };
}

export const ValidatorSetChangePackets: MessageFns<ValidatorSetChangePackets> = {
  encode(message: ValidatorSetChangePackets, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.list) {
      ValidatorSetChangePacketData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatorSetChangePackets {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatorSetChangePackets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.list.push(ValidatorSetChangePacketData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatorSetChangePackets {
    return {
      list: globalThis.Array.isArray(object?.list)
        ? object.list.map((e: any) => ValidatorSetChangePacketData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ValidatorSetChangePackets): unknown {
    const obj: any = {};
    if (message.list?.length) {
      obj.list = message.list.map((e) => ValidatorSetChangePacketData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidatorSetChangePackets>, I>>(base?: I): ValidatorSetChangePackets {
    return ValidatorSetChangePackets.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidatorSetChangePackets>, I>>(object: I): ValidatorSetChangePackets {
    const message = createBaseValidatorSetChangePackets();
    message.list = object.list?.map((e) => ValidatorSetChangePacketData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMaturedUnbondingOps(): MaturedUnbondingOps {
  return { ids: [] };
}

export const MaturedUnbondingOps: MessageFns<MaturedUnbondingOps> = {
  encode(message: MaturedUnbondingOps, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaturedUnbondingOps {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaturedUnbondingOps();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.ids.push(reader.uint64().toString());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaturedUnbondingOps {
    return { ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: MaturedUnbondingOps): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MaturedUnbondingOps>, I>>(base?: I): MaturedUnbondingOps {
    return MaturedUnbondingOps.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MaturedUnbondingOps>, I>>(object: I): MaturedUnbondingOps {
    const message = createBaseMaturedUnbondingOps();
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseExportedVscSendTimestamp(): ExportedVscSendTimestamp {
  return { chainId: "", vscSendTimestamps: [] };
}

export const ExportedVscSendTimestamp: MessageFns<ExportedVscSendTimestamp> = {
  encode(message: ExportedVscSendTimestamp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    for (const v of message.vscSendTimestamps) {
      VscSendTimestamp.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportedVscSendTimestamp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportedVscSendTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.vscSendTimestamps.push(VscSendTimestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportedVscSendTimestamp {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      vscSendTimestamps: globalThis.Array.isArray(object?.vscSendTimestamps)
        ? object.vscSendTimestamps.map((e: any) => VscSendTimestamp.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExportedVscSendTimestamp): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.vscSendTimestamps?.length) {
      obj.vscSendTimestamps = message.vscSendTimestamps.map((e) => VscSendTimestamp.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExportedVscSendTimestamp>, I>>(base?: I): ExportedVscSendTimestamp {
    return ExportedVscSendTimestamp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExportedVscSendTimestamp>, I>>(object: I): ExportedVscSendTimestamp {
    const message = createBaseExportedVscSendTimestamp();
    message.chainId = object.chainId ?? "";
    message.vscSendTimestamps = object.vscSendTimestamps?.map((e) => VscSendTimestamp.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKeyAssignmentReplacement(): KeyAssignmentReplacement {
  return { providerAddr: new Uint8Array(0), prevCKey: undefined, power: "0" };
}

export const KeyAssignmentReplacement: MessageFns<KeyAssignmentReplacement> = {
  encode(message: KeyAssignmentReplacement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerAddr.length !== 0) {
      writer.uint32(10).bytes(message.providerAddr);
    }
    if (message.prevCKey !== undefined) {
      PublicKey.encode(message.prevCKey, writer.uint32(18).fork()).join();
    }
    if (message.power !== "0") {
      writer.uint32(24).int64(message.power);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyAssignmentReplacement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyAssignmentReplacement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerAddr = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prevCKey = PublicKey.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.power = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyAssignmentReplacement {
    return {
      providerAddr: isSet(object.providerAddr) ? bytesFromBase64(object.providerAddr) : new Uint8Array(0),
      prevCKey: isSet(object.prevCKey) ? PublicKey.fromJSON(object.prevCKey) : undefined,
      power: isSet(object.power) ? globalThis.String(object.power) : "0",
    };
  },

  toJSON(message: KeyAssignmentReplacement): unknown {
    const obj: any = {};
    if (message.providerAddr.length !== 0) {
      obj.providerAddr = base64FromBytes(message.providerAddr);
    }
    if (message.prevCKey !== undefined) {
      obj.prevCKey = PublicKey.toJSON(message.prevCKey);
    }
    if (message.power !== "0") {
      obj.power = message.power;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyAssignmentReplacement>, I>>(base?: I): KeyAssignmentReplacement {
    return KeyAssignmentReplacement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyAssignmentReplacement>, I>>(object: I): KeyAssignmentReplacement {
    const message = createBaseKeyAssignmentReplacement();
    message.providerAddr = object.providerAddr ?? new Uint8Array(0);
    message.prevCKey = (object.prevCKey !== undefined && object.prevCKey !== null)
      ? PublicKey.fromPartial(object.prevCKey)
      : undefined;
    message.power = object.power ?? "0";
    return message;
  },
};

function createBaseValidatorConsumerPubKey(): ValidatorConsumerPubKey {
  return { chainId: "", providerAddr: new Uint8Array(0), consumerKey: undefined };
}

export const ValidatorConsumerPubKey: MessageFns<ValidatorConsumerPubKey> = {
  encode(message: ValidatorConsumerPubKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.providerAddr.length !== 0) {
      writer.uint32(18).bytes(message.providerAddr);
    }
    if (message.consumerKey !== undefined) {
      PublicKey.encode(message.consumerKey, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatorConsumerPubKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatorConsumerPubKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerAddr = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.consumerKey = PublicKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatorConsumerPubKey {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      providerAddr: isSet(object.providerAddr) ? bytesFromBase64(object.providerAddr) : new Uint8Array(0),
      consumerKey: isSet(object.consumerKey) ? PublicKey.fromJSON(object.consumerKey) : undefined,
    };
  },

  toJSON(message: ValidatorConsumerPubKey): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.providerAddr.length !== 0) {
      obj.providerAddr = base64FromBytes(message.providerAddr);
    }
    if (message.consumerKey !== undefined) {
      obj.consumerKey = PublicKey.toJSON(message.consumerKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidatorConsumerPubKey>, I>>(base?: I): ValidatorConsumerPubKey {
    return ValidatorConsumerPubKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidatorConsumerPubKey>, I>>(object: I): ValidatorConsumerPubKey {
    const message = createBaseValidatorConsumerPubKey();
    message.chainId = object.chainId ?? "";
    message.providerAddr = object.providerAddr ?? new Uint8Array(0);
    message.consumerKey = (object.consumerKey !== undefined && object.consumerKey !== null)
      ? PublicKey.fromPartial(object.consumerKey)
      : undefined;
    return message;
  },
};

function createBaseValidatorByConsumerAddr(): ValidatorByConsumerAddr {
  return { chainId: "", consumerAddr: new Uint8Array(0), providerAddr: new Uint8Array(0) };
}

export const ValidatorByConsumerAddr: MessageFns<ValidatorByConsumerAddr> = {
  encode(message: ValidatorByConsumerAddr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.consumerAddr.length !== 0) {
      writer.uint32(18).bytes(message.consumerAddr);
    }
    if (message.providerAddr.length !== 0) {
      writer.uint32(26).bytes(message.providerAddr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatorByConsumerAddr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatorByConsumerAddr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.consumerAddr = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.providerAddr = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatorByConsumerAddr {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      consumerAddr: isSet(object.consumerAddr) ? bytesFromBase64(object.consumerAddr) : new Uint8Array(0),
      providerAddr: isSet(object.providerAddr) ? bytesFromBase64(object.providerAddr) : new Uint8Array(0),
    };
  },

  toJSON(message: ValidatorByConsumerAddr): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.consumerAddr.length !== 0) {
      obj.consumerAddr = base64FromBytes(message.consumerAddr);
    }
    if (message.providerAddr.length !== 0) {
      obj.providerAddr = base64FromBytes(message.providerAddr);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidatorByConsumerAddr>, I>>(base?: I): ValidatorByConsumerAddr {
    return ValidatorByConsumerAddr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidatorByConsumerAddr>, I>>(object: I): ValidatorByConsumerAddr {
    const message = createBaseValidatorByConsumerAddr();
    message.chainId = object.chainId ?? "";
    message.consumerAddr = object.consumerAddr ?? new Uint8Array(0);
    message.providerAddr = object.providerAddr ?? new Uint8Array(0);
    return message;
  },
};

function createBaseConsumerAddrsToPrune(): ConsumerAddrsToPrune {
  return { chainId: "", vscId: "0", consumerAddrs: undefined };
}

export const ConsumerAddrsToPrune: MessageFns<ConsumerAddrsToPrune> = {
  encode(message: ConsumerAddrsToPrune, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.vscId !== "0") {
      writer.uint32(16).uint64(message.vscId);
    }
    if (message.consumerAddrs !== undefined) {
      AddressList.encode(message.consumerAddrs, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumerAddrsToPrune {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumerAddrsToPrune();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.vscId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.consumerAddrs = AddressList.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumerAddrsToPrune {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      vscId: isSet(object.vscId) ? globalThis.String(object.vscId) : "0",
      consumerAddrs: isSet(object.consumerAddrs) ? AddressList.fromJSON(object.consumerAddrs) : undefined,
    };
  },

  toJSON(message: ConsumerAddrsToPrune): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.vscId !== "0") {
      obj.vscId = message.vscId;
    }
    if (message.consumerAddrs !== undefined) {
      obj.consumerAddrs = AddressList.toJSON(message.consumerAddrs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumerAddrsToPrune>, I>>(base?: I): ConsumerAddrsToPrune {
    return ConsumerAddrsToPrune.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumerAddrsToPrune>, I>>(object: I): ConsumerAddrsToPrune {
    const message = createBaseConsumerAddrsToPrune();
    message.chainId = object.chainId ?? "";
    message.vscId = object.vscId ?? "0";
    message.consumerAddrs = (object.consumerAddrs !== undefined && object.consumerAddrs !== null)
      ? AddressList.fromPartial(object.consumerAddrs)
      : undefined;
    return message;
  },
};

function createBaseConsumerValidator(): ConsumerValidator {
  return { providerConsAddr: new Uint8Array(0), power: "0", consumerPublicKey: undefined, joinHeight: "0" };
}

export const ConsumerValidator: MessageFns<ConsumerValidator> = {
  encode(message: ConsumerValidator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerConsAddr.length !== 0) {
      writer.uint32(10).bytes(message.providerConsAddr);
    }
    if (message.power !== "0") {
      writer.uint32(16).int64(message.power);
    }
    if (message.consumerPublicKey !== undefined) {
      PublicKey.encode(message.consumerPublicKey, writer.uint32(26).fork()).join();
    }
    if (message.joinHeight !== "0") {
      writer.uint32(32).int64(message.joinHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumerValidator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumerValidator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerConsAddr = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.power = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.consumerPublicKey = PublicKey.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.joinHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumerValidator {
    return {
      providerConsAddr: isSet(object.providerConsAddr) ? bytesFromBase64(object.providerConsAddr) : new Uint8Array(0),
      power: isSet(object.power) ? globalThis.String(object.power) : "0",
      consumerPublicKey: isSet(object.consumerPublicKey) ? PublicKey.fromJSON(object.consumerPublicKey) : undefined,
      joinHeight: isSet(object.joinHeight) ? globalThis.String(object.joinHeight) : "0",
    };
  },

  toJSON(message: ConsumerValidator): unknown {
    const obj: any = {};
    if (message.providerConsAddr.length !== 0) {
      obj.providerConsAddr = base64FromBytes(message.providerConsAddr);
    }
    if (message.power !== "0") {
      obj.power = message.power;
    }
    if (message.consumerPublicKey !== undefined) {
      obj.consumerPublicKey = PublicKey.toJSON(message.consumerPublicKey);
    }
    if (message.joinHeight !== "0") {
      obj.joinHeight = message.joinHeight;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumerValidator>, I>>(base?: I): ConsumerValidator {
    return ConsumerValidator.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumerValidator>, I>>(object: I): ConsumerValidator {
    const message = createBaseConsumerValidator();
    message.providerConsAddr = object.providerConsAddr ?? new Uint8Array(0);
    message.power = object.power ?? "0";
    message.consumerPublicKey = (object.consumerPublicKey !== undefined && object.consumerPublicKey !== null)
      ? PublicKey.fromPartial(object.consumerPublicKey)
      : undefined;
    message.joinHeight = object.joinHeight ?? "0";
    return message;
  },
};

function createBaseConsumerRewardsAllocation(): ConsumerRewardsAllocation {
  return { rewards: [] };
}

export const ConsumerRewardsAllocation: MessageFns<ConsumerRewardsAllocation> = {
  encode(message: ConsumerRewardsAllocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rewards) {
      DecCoin.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumerRewardsAllocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumerRewardsAllocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rewards.push(DecCoin.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumerRewardsAllocation {
    return {
      rewards: globalThis.Array.isArray(object?.rewards) ? object.rewards.map((e: any) => DecCoin.fromJSON(e)) : [],
    };
  },

  toJSON(message: ConsumerRewardsAllocation): unknown {
    const obj: any = {};
    if (message.rewards?.length) {
      obj.rewards = message.rewards.map((e) => DecCoin.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumerRewardsAllocation>, I>>(base?: I): ConsumerRewardsAllocation {
    return ConsumerRewardsAllocation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumerRewardsAllocation>, I>>(object: I): ConsumerRewardsAllocation {
    const message = createBaseConsumerRewardsAllocation();
    message.rewards = object.rewards?.map((e) => DecCoin.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
