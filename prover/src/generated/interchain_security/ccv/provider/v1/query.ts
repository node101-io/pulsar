// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: interchain_security/ccv/provider/v1/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Timestamp } from "../../../../google/protobuf/timestamp.js";
import { PublicKey } from "../../../../tendermint/crypto/keys.js";
import { ConsumerGenesisState } from "../../v1/shared_consumer.js";
import { ConsumerAdditionProposals, ConsumerRemovalProposals, Params, VscSendTimestamp } from "./provider.js";

export const protobufPackage = "interchain_security.ccv.provider.v1";

export interface QueryConsumerGenesisRequest {
  chainId: string;
}

export interface QueryConsumerGenesisResponse {
  genesisState?: ConsumerGenesisState | undefined;
}

export interface QueryConsumerChainsRequest {
}

export interface QueryConsumerChainsResponse {
  chains: Chain[];
}

export interface QueryConsumerChainStartProposalsRequest {
}

export interface QueryConsumerChainStartProposalsResponse {
  proposals?: ConsumerAdditionProposals | undefined;
}

export interface QueryConsumerChainStopProposalsRequest {
}

export interface QueryConsumerChainStopProposalsResponse {
  proposals?: ConsumerRemovalProposals | undefined;
}

export interface Chain {
  chainId: string;
  clientId: string;
  /** If chain with `chainID` is a Top-N chain, i.e., enforces at least one validator to validate chain `chainID` */
  topN: number;
  /**
   * If the chain is a Top-N chain, this is the minimum power required to be in the top N.
   * Otherwise, this is -1.
   */
  minPowerInTopN: string;
  /** Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. */
  validatorsPowerCap: number;
  /**
   * Corresponds to the maximum number of validators that can validate a consumer chain.
   * Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op.
   */
  validatorSetCap: number;
  /**
   * Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate
   * the consumer chain.
   */
  allowlist: string[];
  /** Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain. */
  denylist: string[];
}

export interface QueryValidatorConsumerAddrRequest {
  /** The id of the consumer chain */
  chainId: string;
  /** The consensus address of the validator on the provider chain */
  providerAddress: string;
}

export interface QueryValidatorConsumerAddrResponse {
  /** The address of the validator on the consumer chain */
  consumerAddress: string;
}

export interface QueryValidatorProviderAddrRequest {
  /** The id of the provider chain */
  chainId: string;
  /** The consensus address of the validator on the consumer chain */
  consumerAddress: string;
}

export interface QueryValidatorProviderAddrResponse {
  /** The address of the validator on the provider chain */
  providerAddress: string;
}

export interface QueryThrottleStateRequest {
}

export interface QueryThrottleStateResponse {
  /** current slash_meter state */
  slashMeter: string;
  /**
   * allowance of voting power units (int) that the slash meter is given per
   * replenish period this also serves as the max value for the meter.
   */
  slashMeterAllowance: string;
  /**
   * next time the slash meter could potentially be replenished, iff it's not
   * full
   */
  nextReplenishCandidate?: Date | undefined;
}

export interface QueryRegisteredConsumerRewardDenomsRequest {
}

export interface QueryRegisteredConsumerRewardDenomsResponse {
  denoms: string[];
}

export interface QueryProposedChainIDsRequest {
}

export interface QueryProposedChainIDsResponse {
  proposedChains: ProposedChain[];
}

export interface ProposedChain {
  chainID: string;
  proposalID: string;
}

export interface QueryAllPairsValConAddrByConsumerChainIDRequest {
  /** The id of the consumer chain */
  chainId: string;
}

export interface QueryAllPairsValConAddrByConsumerChainIDResponse {
  pairValConAddr: PairValConAddrProviderAndConsumer[];
}

export interface PairValConAddrProviderAndConsumer {
  /** The consensus address of the validator on the provider chain */
  providerAddress: string;
  /** The consensus address of the validator on the consumer chain */
  consumerAddress: string;
  consumerKey?: PublicKey | undefined;
}

export interface QueryParamsRequest {
}

export interface QueryParamsResponse {
  params?: Params | undefined;
}

export interface QueryConsumerChainOptedInValidatorsRequest {
  chainId: string;
}

export interface QueryConsumerChainOptedInValidatorsResponse {
  /** The consensus addresses of the validators on the provider chain */
  validatorsProviderAddresses: string[];
}

export interface QueryConsumerValidatorsRequest {
  chainId: string;
}

export interface QueryConsumerValidatorsValidator {
  /** The consensus address of the validator on the provider chain */
  providerAddress: string;
  /** The consumer public key of the validator used on the consumer chain */
  consumerKey?:
    | PublicKey
    | undefined;
  /** The power of the validator used on the consumer chain */
  power: string;
}

export interface QueryConsumerValidatorsResponse {
  validators: QueryConsumerValidatorsValidator[];
}

export interface QueryConsumerChainsValidatorHasToValidateRequest {
  /** The consensus address of the validator on the provider chain */
  providerAddress: string;
}

export interface QueryConsumerChainsValidatorHasToValidateResponse {
  consumerChainIds: string[];
}

export interface QueryValidatorConsumerCommissionRateRequest {
  chainId: string;
  /** The consensus address of the validator on the provider chain */
  providerAddress: string;
}

export interface QueryValidatorConsumerCommissionRateResponse {
  /** The rate to charge delegators on the consumer chain, as a fraction */
  rate: string;
}

export interface QueryOldestUnconfirmedVscRequest {
  chainId: string;
}

export interface QueryOldestUnconfirmedVscResponse {
  vscSendTimestamp?: VscSendTimestamp | undefined;
}

function createBaseQueryConsumerGenesisRequest(): QueryConsumerGenesisRequest {
  return { chainId: "" };
}

export const QueryConsumerGenesisRequest: MessageFns<QueryConsumerGenesisRequest> = {
  encode(message: QueryConsumerGenesisRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryConsumerGenesisRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryConsumerGenesisRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryConsumerGenesisRequest {
    return { chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "" };
  },

  toJSON(message: QueryConsumerGenesisRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryConsumerGenesisRequest>, I>>(base?: I): QueryConsumerGenesisRequest {
    return QueryConsumerGenesisRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryConsumerGenesisRequest>, I>>(object: I): QueryConsumerGenesisRequest {
    const message = createBaseQueryConsumerGenesisRequest();
    message.chainId = object.chainId ?? "";
    return message;
  },
};

function createBaseQueryConsumerGenesisResponse(): QueryConsumerGenesisResponse {
  return { genesisState: undefined };
}

export const QueryConsumerGenesisResponse: MessageFns<QueryConsumerGenesisResponse> = {
  encode(message: QueryConsumerGenesisResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.genesisState !== undefined) {
      ConsumerGenesisState.encode(message.genesisState, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryConsumerGenesisResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryConsumerGenesisResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.genesisState = ConsumerGenesisState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryConsumerGenesisResponse {
    return {
      genesisState: isSet(object.genesisState) ? ConsumerGenesisState.fromJSON(object.genesisState) : undefined,
    };
  },

  toJSON(message: QueryConsumerGenesisResponse): unknown {
    const obj: any = {};
    if (message.genesisState !== undefined) {
      obj.genesisState = ConsumerGenesisState.toJSON(message.genesisState);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryConsumerGenesisResponse>, I>>(base?: I): QueryConsumerGenesisResponse {
    return QueryConsumerGenesisResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryConsumerGenesisResponse>, I>>(object: I): QueryConsumerGenesisResponse {
    const message = createBaseQueryConsumerGenesisResponse();
    message.genesisState = (object.genesisState !== undefined && object.genesisState !== null)
      ? ConsumerGenesisState.fromPartial(object.genesisState)
      : undefined;
    return message;
  },
};

function createBaseQueryConsumerChainsRequest(): QueryConsumerChainsRequest {
  return {};
}

export const QueryConsumerChainsRequest: MessageFns<QueryConsumerChainsRequest> = {
  encode(_: QueryConsumerChainsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryConsumerChainsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryConsumerChainsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryConsumerChainsRequest {
    return {};
  },

  toJSON(_: QueryConsumerChainsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryConsumerChainsRequest>, I>>(base?: I): QueryConsumerChainsRequest {
    return QueryConsumerChainsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryConsumerChainsRequest>, I>>(_: I): QueryConsumerChainsRequest {
    const message = createBaseQueryConsumerChainsRequest();
    return message;
  },
};

function createBaseQueryConsumerChainsResponse(): QueryConsumerChainsResponse {
  return { chains: [] };
}

export const QueryConsumerChainsResponse: MessageFns<QueryConsumerChainsResponse> = {
  encode(message: QueryConsumerChainsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.chains) {
      Chain.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryConsumerChainsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryConsumerChainsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chains.push(Chain.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryConsumerChainsResponse {
    return { chains: globalThis.Array.isArray(object?.chains) ? object.chains.map((e: any) => Chain.fromJSON(e)) : [] };
  },

  toJSON(message: QueryConsumerChainsResponse): unknown {
    const obj: any = {};
    if (message.chains?.length) {
      obj.chains = message.chains.map((e) => Chain.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryConsumerChainsResponse>, I>>(base?: I): QueryConsumerChainsResponse {
    return QueryConsumerChainsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryConsumerChainsResponse>, I>>(object: I): QueryConsumerChainsResponse {
    const message = createBaseQueryConsumerChainsResponse();
    message.chains = object.chains?.map((e) => Chain.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryConsumerChainStartProposalsRequest(): QueryConsumerChainStartProposalsRequest {
  return {};
}

export const QueryConsumerChainStartProposalsRequest: MessageFns<QueryConsumerChainStartProposalsRequest> = {
  encode(_: QueryConsumerChainStartProposalsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryConsumerChainStartProposalsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryConsumerChainStartProposalsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryConsumerChainStartProposalsRequest {
    return {};
  },

  toJSON(_: QueryConsumerChainStartProposalsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryConsumerChainStartProposalsRequest>, I>>(
    base?: I,
  ): QueryConsumerChainStartProposalsRequest {
    return QueryConsumerChainStartProposalsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryConsumerChainStartProposalsRequest>, I>>(
    _: I,
  ): QueryConsumerChainStartProposalsRequest {
    const message = createBaseQueryConsumerChainStartProposalsRequest();
    return message;
  },
};

function createBaseQueryConsumerChainStartProposalsResponse(): QueryConsumerChainStartProposalsResponse {
  return { proposals: undefined };
}

export const QueryConsumerChainStartProposalsResponse: MessageFns<QueryConsumerChainStartProposalsResponse> = {
  encode(message: QueryConsumerChainStartProposalsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proposals !== undefined) {
      ConsumerAdditionProposals.encode(message.proposals, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryConsumerChainStartProposalsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryConsumerChainStartProposalsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proposals = ConsumerAdditionProposals.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryConsumerChainStartProposalsResponse {
    return { proposals: isSet(object.proposals) ? ConsumerAdditionProposals.fromJSON(object.proposals) : undefined };
  },

  toJSON(message: QueryConsumerChainStartProposalsResponse): unknown {
    const obj: any = {};
    if (message.proposals !== undefined) {
      obj.proposals = ConsumerAdditionProposals.toJSON(message.proposals);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryConsumerChainStartProposalsResponse>, I>>(
    base?: I,
  ): QueryConsumerChainStartProposalsResponse {
    return QueryConsumerChainStartProposalsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryConsumerChainStartProposalsResponse>, I>>(
    object: I,
  ): QueryConsumerChainStartProposalsResponse {
    const message = createBaseQueryConsumerChainStartProposalsResponse();
    message.proposals = (object.proposals !== undefined && object.proposals !== null)
      ? ConsumerAdditionProposals.fromPartial(object.proposals)
      : undefined;
    return message;
  },
};

function createBaseQueryConsumerChainStopProposalsRequest(): QueryConsumerChainStopProposalsRequest {
  return {};
}

export const QueryConsumerChainStopProposalsRequest: MessageFns<QueryConsumerChainStopProposalsRequest> = {
  encode(_: QueryConsumerChainStopProposalsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryConsumerChainStopProposalsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryConsumerChainStopProposalsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryConsumerChainStopProposalsRequest {
    return {};
  },

  toJSON(_: QueryConsumerChainStopProposalsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryConsumerChainStopProposalsRequest>, I>>(
    base?: I,
  ): QueryConsumerChainStopProposalsRequest {
    return QueryConsumerChainStopProposalsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryConsumerChainStopProposalsRequest>, I>>(
    _: I,
  ): QueryConsumerChainStopProposalsRequest {
    const message = createBaseQueryConsumerChainStopProposalsRequest();
    return message;
  },
};

function createBaseQueryConsumerChainStopProposalsResponse(): QueryConsumerChainStopProposalsResponse {
  return { proposals: undefined };
}

export const QueryConsumerChainStopProposalsResponse: MessageFns<QueryConsumerChainStopProposalsResponse> = {
  encode(message: QueryConsumerChainStopProposalsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proposals !== undefined) {
      ConsumerRemovalProposals.encode(message.proposals, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryConsumerChainStopProposalsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryConsumerChainStopProposalsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proposals = ConsumerRemovalProposals.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryConsumerChainStopProposalsResponse {
    return { proposals: isSet(object.proposals) ? ConsumerRemovalProposals.fromJSON(object.proposals) : undefined };
  },

  toJSON(message: QueryConsumerChainStopProposalsResponse): unknown {
    const obj: any = {};
    if (message.proposals !== undefined) {
      obj.proposals = ConsumerRemovalProposals.toJSON(message.proposals);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryConsumerChainStopProposalsResponse>, I>>(
    base?: I,
  ): QueryConsumerChainStopProposalsResponse {
    return QueryConsumerChainStopProposalsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryConsumerChainStopProposalsResponse>, I>>(
    object: I,
  ): QueryConsumerChainStopProposalsResponse {
    const message = createBaseQueryConsumerChainStopProposalsResponse();
    message.proposals = (object.proposals !== undefined && object.proposals !== null)
      ? ConsumerRemovalProposals.fromPartial(object.proposals)
      : undefined;
    return message;
  },
};

function createBaseChain(): Chain {
  return {
    chainId: "",
    clientId: "",
    topN: 0,
    minPowerInTopN: "0",
    validatorsPowerCap: 0,
    validatorSetCap: 0,
    allowlist: [],
    denylist: [],
  };
}

export const Chain: MessageFns<Chain> = {
  encode(message: Chain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.topN !== 0) {
      writer.uint32(24).uint32(message.topN);
    }
    if (message.minPowerInTopN !== "0") {
      writer.uint32(32).int64(message.minPowerInTopN);
    }
    if (message.validatorsPowerCap !== 0) {
      writer.uint32(40).uint32(message.validatorsPowerCap);
    }
    if (message.validatorSetCap !== 0) {
      writer.uint32(48).uint32(message.validatorSetCap);
    }
    for (const v of message.allowlist) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.denylist) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Chain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.topN = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.minPowerInTopN = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.validatorsPowerCap = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.validatorSetCap = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.allowlist.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.denylist.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Chain {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      topN: isSet(object.topN) ? globalThis.Number(object.topN) : 0,
      minPowerInTopN: isSet(object.minPowerInTopN) ? globalThis.String(object.minPowerInTopN) : "0",
      validatorsPowerCap: isSet(object.validatorsPowerCap) ? globalThis.Number(object.validatorsPowerCap) : 0,
      validatorSetCap: isSet(object.validatorSetCap) ? globalThis.Number(object.validatorSetCap) : 0,
      allowlist: globalThis.Array.isArray(object?.allowlist)
        ? object.allowlist.map((e: any) => globalThis.String(e))
        : [],
      denylist: globalThis.Array.isArray(object?.denylist) ? object.denylist.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Chain): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.topN !== 0) {
      obj.topN = Math.round(message.topN);
    }
    if (message.minPowerInTopN !== "0") {
      obj.minPowerInTopN = message.minPowerInTopN;
    }
    if (message.validatorsPowerCap !== 0) {
      obj.validatorsPowerCap = Math.round(message.validatorsPowerCap);
    }
    if (message.validatorSetCap !== 0) {
      obj.validatorSetCap = Math.round(message.validatorSetCap);
    }
    if (message.allowlist?.length) {
      obj.allowlist = message.allowlist;
    }
    if (message.denylist?.length) {
      obj.denylist = message.denylist;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Chain>, I>>(base?: I): Chain {
    return Chain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Chain>, I>>(object: I): Chain {
    const message = createBaseChain();
    message.chainId = object.chainId ?? "";
    message.clientId = object.clientId ?? "";
    message.topN = object.topN ?? 0;
    message.minPowerInTopN = object.minPowerInTopN ?? "0";
    message.validatorsPowerCap = object.validatorsPowerCap ?? 0;
    message.validatorSetCap = object.validatorSetCap ?? 0;
    message.allowlist = object.allowlist?.map((e) => e) || [];
    message.denylist = object.denylist?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryValidatorConsumerAddrRequest(): QueryValidatorConsumerAddrRequest {
  return { chainId: "", providerAddress: "" };
}

export const QueryValidatorConsumerAddrRequest: MessageFns<QueryValidatorConsumerAddrRequest> = {
  encode(message: QueryValidatorConsumerAddrRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.providerAddress !== "") {
      writer.uint32(18).string(message.providerAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryValidatorConsumerAddrRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidatorConsumerAddrRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidatorConsumerAddrRequest {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      providerAddress: isSet(object.providerAddress) ? globalThis.String(object.providerAddress) : "",
    };
  },

  toJSON(message: QueryValidatorConsumerAddrRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.providerAddress !== "") {
      obj.providerAddress = message.providerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryValidatorConsumerAddrRequest>, I>>(
    base?: I,
  ): QueryValidatorConsumerAddrRequest {
    return QueryValidatorConsumerAddrRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryValidatorConsumerAddrRequest>, I>>(
    object: I,
  ): QueryValidatorConsumerAddrRequest {
    const message = createBaseQueryValidatorConsumerAddrRequest();
    message.chainId = object.chainId ?? "";
    message.providerAddress = object.providerAddress ?? "";
    return message;
  },
};

function createBaseQueryValidatorConsumerAddrResponse(): QueryValidatorConsumerAddrResponse {
  return { consumerAddress: "" };
}

export const QueryValidatorConsumerAddrResponse: MessageFns<QueryValidatorConsumerAddrResponse> = {
  encode(message: QueryValidatorConsumerAddrResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consumerAddress !== "") {
      writer.uint32(10).string(message.consumerAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryValidatorConsumerAddrResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidatorConsumerAddrResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consumerAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidatorConsumerAddrResponse {
    return { consumerAddress: isSet(object.consumerAddress) ? globalThis.String(object.consumerAddress) : "" };
  },

  toJSON(message: QueryValidatorConsumerAddrResponse): unknown {
    const obj: any = {};
    if (message.consumerAddress !== "") {
      obj.consumerAddress = message.consumerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryValidatorConsumerAddrResponse>, I>>(
    base?: I,
  ): QueryValidatorConsumerAddrResponse {
    return QueryValidatorConsumerAddrResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryValidatorConsumerAddrResponse>, I>>(
    object: I,
  ): QueryValidatorConsumerAddrResponse {
    const message = createBaseQueryValidatorConsumerAddrResponse();
    message.consumerAddress = object.consumerAddress ?? "";
    return message;
  },
};

function createBaseQueryValidatorProviderAddrRequest(): QueryValidatorProviderAddrRequest {
  return { chainId: "", consumerAddress: "" };
}

export const QueryValidatorProviderAddrRequest: MessageFns<QueryValidatorProviderAddrRequest> = {
  encode(message: QueryValidatorProviderAddrRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.consumerAddress !== "") {
      writer.uint32(18).string(message.consumerAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryValidatorProviderAddrRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidatorProviderAddrRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.consumerAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidatorProviderAddrRequest {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      consumerAddress: isSet(object.consumerAddress) ? globalThis.String(object.consumerAddress) : "",
    };
  },

  toJSON(message: QueryValidatorProviderAddrRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.consumerAddress !== "") {
      obj.consumerAddress = message.consumerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryValidatorProviderAddrRequest>, I>>(
    base?: I,
  ): QueryValidatorProviderAddrRequest {
    return QueryValidatorProviderAddrRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryValidatorProviderAddrRequest>, I>>(
    object: I,
  ): QueryValidatorProviderAddrRequest {
    const message = createBaseQueryValidatorProviderAddrRequest();
    message.chainId = object.chainId ?? "";
    message.consumerAddress = object.consumerAddress ?? "";
    return message;
  },
};

function createBaseQueryValidatorProviderAddrResponse(): QueryValidatorProviderAddrResponse {
  return { providerAddress: "" };
}

export const QueryValidatorProviderAddrResponse: MessageFns<QueryValidatorProviderAddrResponse> = {
  encode(message: QueryValidatorProviderAddrResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerAddress !== "") {
      writer.uint32(10).string(message.providerAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryValidatorProviderAddrResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidatorProviderAddrResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidatorProviderAddrResponse {
    return { providerAddress: isSet(object.providerAddress) ? globalThis.String(object.providerAddress) : "" };
  },

  toJSON(message: QueryValidatorProviderAddrResponse): unknown {
    const obj: any = {};
    if (message.providerAddress !== "") {
      obj.providerAddress = message.providerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryValidatorProviderAddrResponse>, I>>(
    base?: I,
  ): QueryValidatorProviderAddrResponse {
    return QueryValidatorProviderAddrResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryValidatorProviderAddrResponse>, I>>(
    object: I,
  ): QueryValidatorProviderAddrResponse {
    const message = createBaseQueryValidatorProviderAddrResponse();
    message.providerAddress = object.providerAddress ?? "";
    return message;
  },
};

function createBaseQueryThrottleStateRequest(): QueryThrottleStateRequest {
  return {};
}

export const QueryThrottleStateRequest: MessageFns<QueryThrottleStateRequest> = {
  encode(_: QueryThrottleStateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryThrottleStateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryThrottleStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryThrottleStateRequest {
    return {};
  },

  toJSON(_: QueryThrottleStateRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryThrottleStateRequest>, I>>(base?: I): QueryThrottleStateRequest {
    return QueryThrottleStateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryThrottleStateRequest>, I>>(_: I): QueryThrottleStateRequest {
    const message = createBaseQueryThrottleStateRequest();
    return message;
  },
};

function createBaseQueryThrottleStateResponse(): QueryThrottleStateResponse {
  return { slashMeter: "0", slashMeterAllowance: "0", nextReplenishCandidate: undefined };
}

export const QueryThrottleStateResponse: MessageFns<QueryThrottleStateResponse> = {
  encode(message: QueryThrottleStateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slashMeter !== "0") {
      writer.uint32(8).int64(message.slashMeter);
    }
    if (message.slashMeterAllowance !== "0") {
      writer.uint32(16).int64(message.slashMeterAllowance);
    }
    if (message.nextReplenishCandidate !== undefined) {
      Timestamp.encode(toTimestamp(message.nextReplenishCandidate), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryThrottleStateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryThrottleStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.slashMeter = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.slashMeterAllowance = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nextReplenishCandidate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryThrottleStateResponse {
    return {
      slashMeter: isSet(object.slashMeter) ? globalThis.String(object.slashMeter) : "0",
      slashMeterAllowance: isSet(object.slashMeterAllowance) ? globalThis.String(object.slashMeterAllowance) : "0",
      nextReplenishCandidate: isSet(object.nextReplenishCandidate)
        ? fromJsonTimestamp(object.nextReplenishCandidate)
        : undefined,
    };
  },

  toJSON(message: QueryThrottleStateResponse): unknown {
    const obj: any = {};
    if (message.slashMeter !== "0") {
      obj.slashMeter = message.slashMeter;
    }
    if (message.slashMeterAllowance !== "0") {
      obj.slashMeterAllowance = message.slashMeterAllowance;
    }
    if (message.nextReplenishCandidate !== undefined) {
      obj.nextReplenishCandidate = message.nextReplenishCandidate.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryThrottleStateResponse>, I>>(base?: I): QueryThrottleStateResponse {
    return QueryThrottleStateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryThrottleStateResponse>, I>>(object: I): QueryThrottleStateResponse {
    const message = createBaseQueryThrottleStateResponse();
    message.slashMeter = object.slashMeter ?? "0";
    message.slashMeterAllowance = object.slashMeterAllowance ?? "0";
    message.nextReplenishCandidate = object.nextReplenishCandidate ?? undefined;
    return message;
  },
};

function createBaseQueryRegisteredConsumerRewardDenomsRequest(): QueryRegisteredConsumerRewardDenomsRequest {
  return {};
}

export const QueryRegisteredConsumerRewardDenomsRequest: MessageFns<QueryRegisteredConsumerRewardDenomsRequest> = {
  encode(_: QueryRegisteredConsumerRewardDenomsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryRegisteredConsumerRewardDenomsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRegisteredConsumerRewardDenomsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryRegisteredConsumerRewardDenomsRequest {
    return {};
  },

  toJSON(_: QueryRegisteredConsumerRewardDenomsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRegisteredConsumerRewardDenomsRequest>, I>>(
    base?: I,
  ): QueryRegisteredConsumerRewardDenomsRequest {
    return QueryRegisteredConsumerRewardDenomsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRegisteredConsumerRewardDenomsRequest>, I>>(
    _: I,
  ): QueryRegisteredConsumerRewardDenomsRequest {
    const message = createBaseQueryRegisteredConsumerRewardDenomsRequest();
    return message;
  },
};

function createBaseQueryRegisteredConsumerRewardDenomsResponse(): QueryRegisteredConsumerRewardDenomsResponse {
  return { denoms: [] };
}

export const QueryRegisteredConsumerRewardDenomsResponse: MessageFns<QueryRegisteredConsumerRewardDenomsResponse> = {
  encode(
    message: QueryRegisteredConsumerRewardDenomsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.denoms) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryRegisteredConsumerRewardDenomsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRegisteredConsumerRewardDenomsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denoms.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRegisteredConsumerRewardDenomsResponse {
    return {
      denoms: globalThis.Array.isArray(object?.denoms) ? object.denoms.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: QueryRegisteredConsumerRewardDenomsResponse): unknown {
    const obj: any = {};
    if (message.denoms?.length) {
      obj.denoms = message.denoms;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRegisteredConsumerRewardDenomsResponse>, I>>(
    base?: I,
  ): QueryRegisteredConsumerRewardDenomsResponse {
    return QueryRegisteredConsumerRewardDenomsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRegisteredConsumerRewardDenomsResponse>, I>>(
    object: I,
  ): QueryRegisteredConsumerRewardDenomsResponse {
    const message = createBaseQueryRegisteredConsumerRewardDenomsResponse();
    message.denoms = object.denoms?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryProposedChainIDsRequest(): QueryProposedChainIDsRequest {
  return {};
}

export const QueryProposedChainIDsRequest: MessageFns<QueryProposedChainIDsRequest> = {
  encode(_: QueryProposedChainIDsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryProposedChainIDsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProposedChainIDsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryProposedChainIDsRequest {
    return {};
  },

  toJSON(_: QueryProposedChainIDsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryProposedChainIDsRequest>, I>>(base?: I): QueryProposedChainIDsRequest {
    return QueryProposedChainIDsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryProposedChainIDsRequest>, I>>(_: I): QueryProposedChainIDsRequest {
    const message = createBaseQueryProposedChainIDsRequest();
    return message;
  },
};

function createBaseQueryProposedChainIDsResponse(): QueryProposedChainIDsResponse {
  return { proposedChains: [] };
}

export const QueryProposedChainIDsResponse: MessageFns<QueryProposedChainIDsResponse> = {
  encode(message: QueryProposedChainIDsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.proposedChains) {
      ProposedChain.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryProposedChainIDsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProposedChainIDsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proposedChains.push(ProposedChain.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryProposedChainIDsResponse {
    return {
      proposedChains: globalThis.Array.isArray(object?.proposedChains)
        ? object.proposedChains.map((e: any) => ProposedChain.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryProposedChainIDsResponse): unknown {
    const obj: any = {};
    if (message.proposedChains?.length) {
      obj.proposedChains = message.proposedChains.map((e) => ProposedChain.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryProposedChainIDsResponse>, I>>(base?: I): QueryProposedChainIDsResponse {
    return QueryProposedChainIDsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryProposedChainIDsResponse>, I>>(
    object: I,
  ): QueryProposedChainIDsResponse {
    const message = createBaseQueryProposedChainIDsResponse();
    message.proposedChains = object.proposedChains?.map((e) => ProposedChain.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProposedChain(): ProposedChain {
  return { chainID: "", proposalID: "0" };
}

export const ProposedChain: MessageFns<ProposedChain> = {
  encode(message: ProposedChain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainID !== "") {
      writer.uint32(10).string(message.chainID);
    }
    if (message.proposalID !== "0") {
      writer.uint32(16).uint64(message.proposalID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProposedChain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProposedChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.proposalID = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProposedChain {
    return {
      chainID: isSet(object.chainID) ? globalThis.String(object.chainID) : "",
      proposalID: isSet(object.proposalID) ? globalThis.String(object.proposalID) : "0",
    };
  },

  toJSON(message: ProposedChain): unknown {
    const obj: any = {};
    if (message.chainID !== "") {
      obj.chainID = message.chainID;
    }
    if (message.proposalID !== "0") {
      obj.proposalID = message.proposalID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProposedChain>, I>>(base?: I): ProposedChain {
    return ProposedChain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProposedChain>, I>>(object: I): ProposedChain {
    const message = createBaseProposedChain();
    message.chainID = object.chainID ?? "";
    message.proposalID = object.proposalID ?? "0";
    return message;
  },
};

function createBaseQueryAllPairsValConAddrByConsumerChainIDRequest(): QueryAllPairsValConAddrByConsumerChainIDRequest {
  return { chainId: "" };
}

export const QueryAllPairsValConAddrByConsumerChainIDRequest: MessageFns<
  QueryAllPairsValConAddrByConsumerChainIDRequest
> = {
  encode(
    message: QueryAllPairsValConAddrByConsumerChainIDRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllPairsValConAddrByConsumerChainIDRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllPairsValConAddrByConsumerChainIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllPairsValConAddrByConsumerChainIDRequest {
    return { chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "" };
  },

  toJSON(message: QueryAllPairsValConAddrByConsumerChainIDRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllPairsValConAddrByConsumerChainIDRequest>, I>>(
    base?: I,
  ): QueryAllPairsValConAddrByConsumerChainIDRequest {
    return QueryAllPairsValConAddrByConsumerChainIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllPairsValConAddrByConsumerChainIDRequest>, I>>(
    object: I,
  ): QueryAllPairsValConAddrByConsumerChainIDRequest {
    const message = createBaseQueryAllPairsValConAddrByConsumerChainIDRequest();
    message.chainId = object.chainId ?? "";
    return message;
  },
};

function createBaseQueryAllPairsValConAddrByConsumerChainIDResponse(): QueryAllPairsValConAddrByConsumerChainIDResponse {
  return { pairValConAddr: [] };
}

export const QueryAllPairsValConAddrByConsumerChainIDResponse: MessageFns<
  QueryAllPairsValConAddrByConsumerChainIDResponse
> = {
  encode(
    message: QueryAllPairsValConAddrByConsumerChainIDResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.pairValConAddr) {
      PairValConAddrProviderAndConsumer.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllPairsValConAddrByConsumerChainIDResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllPairsValConAddrByConsumerChainIDResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pairValConAddr.push(PairValConAddrProviderAndConsumer.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllPairsValConAddrByConsumerChainIDResponse {
    return {
      pairValConAddr: globalThis.Array.isArray(object?.pairValConAddr)
        ? object.pairValConAddr.map((e: any) => PairValConAddrProviderAndConsumer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryAllPairsValConAddrByConsumerChainIDResponse): unknown {
    const obj: any = {};
    if (message.pairValConAddr?.length) {
      obj.pairValConAddr = message.pairValConAddr.map((e) => PairValConAddrProviderAndConsumer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllPairsValConAddrByConsumerChainIDResponse>, I>>(
    base?: I,
  ): QueryAllPairsValConAddrByConsumerChainIDResponse {
    return QueryAllPairsValConAddrByConsumerChainIDResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllPairsValConAddrByConsumerChainIDResponse>, I>>(
    object: I,
  ): QueryAllPairsValConAddrByConsumerChainIDResponse {
    const message = createBaseQueryAllPairsValConAddrByConsumerChainIDResponse();
    message.pairValConAddr = object.pairValConAddr?.map((e) => PairValConAddrProviderAndConsumer.fromPartial(e)) || [];
    return message;
  },
};

function createBasePairValConAddrProviderAndConsumer(): PairValConAddrProviderAndConsumer {
  return { providerAddress: "", consumerAddress: "", consumerKey: undefined };
}

export const PairValConAddrProviderAndConsumer: MessageFns<PairValConAddrProviderAndConsumer> = {
  encode(message: PairValConAddrProviderAndConsumer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerAddress !== "") {
      writer.uint32(10).string(message.providerAddress);
    }
    if (message.consumerAddress !== "") {
      writer.uint32(18).string(message.consumerAddress);
    }
    if (message.consumerKey !== undefined) {
      PublicKey.encode(message.consumerKey, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PairValConAddrProviderAndConsumer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePairValConAddrProviderAndConsumer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.consumerAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.consumerKey = PublicKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PairValConAddrProviderAndConsumer {
    return {
      providerAddress: isSet(object.providerAddress) ? globalThis.String(object.providerAddress) : "",
      consumerAddress: isSet(object.consumerAddress) ? globalThis.String(object.consumerAddress) : "",
      consumerKey: isSet(object.consumerKey) ? PublicKey.fromJSON(object.consumerKey) : undefined,
    };
  },

  toJSON(message: PairValConAddrProviderAndConsumer): unknown {
    const obj: any = {};
    if (message.providerAddress !== "") {
      obj.providerAddress = message.providerAddress;
    }
    if (message.consumerAddress !== "") {
      obj.consumerAddress = message.consumerAddress;
    }
    if (message.consumerKey !== undefined) {
      obj.consumerKey = PublicKey.toJSON(message.consumerKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PairValConAddrProviderAndConsumer>, I>>(
    base?: I,
  ): PairValConAddrProviderAndConsumer {
    return PairValConAddrProviderAndConsumer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PairValConAddrProviderAndConsumer>, I>>(
    object: I,
  ): PairValConAddrProviderAndConsumer {
    const message = createBasePairValConAddrProviderAndConsumer();
    message.providerAddress = object.providerAddress ?? "";
    message.consumerAddress = object.consumerAddress ?? "";
    message.consumerKey = (object.consumerKey !== undefined && object.consumerKey !== null)
      ? PublicKey.fromPartial(object.consumerKey)
      : undefined;
    return message;
  },
};

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(_: QueryParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(message: QueryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryConsumerChainOptedInValidatorsRequest(): QueryConsumerChainOptedInValidatorsRequest {
  return { chainId: "" };
}

export const QueryConsumerChainOptedInValidatorsRequest: MessageFns<QueryConsumerChainOptedInValidatorsRequest> = {
  encode(message: QueryConsumerChainOptedInValidatorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryConsumerChainOptedInValidatorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryConsumerChainOptedInValidatorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryConsumerChainOptedInValidatorsRequest {
    return { chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "" };
  },

  toJSON(message: QueryConsumerChainOptedInValidatorsRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryConsumerChainOptedInValidatorsRequest>, I>>(
    base?: I,
  ): QueryConsumerChainOptedInValidatorsRequest {
    return QueryConsumerChainOptedInValidatorsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryConsumerChainOptedInValidatorsRequest>, I>>(
    object: I,
  ): QueryConsumerChainOptedInValidatorsRequest {
    const message = createBaseQueryConsumerChainOptedInValidatorsRequest();
    message.chainId = object.chainId ?? "";
    return message;
  },
};

function createBaseQueryConsumerChainOptedInValidatorsResponse(): QueryConsumerChainOptedInValidatorsResponse {
  return { validatorsProviderAddresses: [] };
}

export const QueryConsumerChainOptedInValidatorsResponse: MessageFns<QueryConsumerChainOptedInValidatorsResponse> = {
  encode(
    message: QueryConsumerChainOptedInValidatorsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.validatorsProviderAddresses) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryConsumerChainOptedInValidatorsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryConsumerChainOptedInValidatorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorsProviderAddresses.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryConsumerChainOptedInValidatorsResponse {
    return {
      validatorsProviderAddresses: globalThis.Array.isArray(object?.validatorsProviderAddresses)
        ? object.validatorsProviderAddresses.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: QueryConsumerChainOptedInValidatorsResponse): unknown {
    const obj: any = {};
    if (message.validatorsProviderAddresses?.length) {
      obj.validatorsProviderAddresses = message.validatorsProviderAddresses;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryConsumerChainOptedInValidatorsResponse>, I>>(
    base?: I,
  ): QueryConsumerChainOptedInValidatorsResponse {
    return QueryConsumerChainOptedInValidatorsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryConsumerChainOptedInValidatorsResponse>, I>>(
    object: I,
  ): QueryConsumerChainOptedInValidatorsResponse {
    const message = createBaseQueryConsumerChainOptedInValidatorsResponse();
    message.validatorsProviderAddresses = object.validatorsProviderAddresses?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryConsumerValidatorsRequest(): QueryConsumerValidatorsRequest {
  return { chainId: "" };
}

export const QueryConsumerValidatorsRequest: MessageFns<QueryConsumerValidatorsRequest> = {
  encode(message: QueryConsumerValidatorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryConsumerValidatorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryConsumerValidatorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryConsumerValidatorsRequest {
    return { chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "" };
  },

  toJSON(message: QueryConsumerValidatorsRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryConsumerValidatorsRequest>, I>>(base?: I): QueryConsumerValidatorsRequest {
    return QueryConsumerValidatorsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryConsumerValidatorsRequest>, I>>(
    object: I,
  ): QueryConsumerValidatorsRequest {
    const message = createBaseQueryConsumerValidatorsRequest();
    message.chainId = object.chainId ?? "";
    return message;
  },
};

function createBaseQueryConsumerValidatorsValidator(): QueryConsumerValidatorsValidator {
  return { providerAddress: "", consumerKey: undefined, power: "0" };
}

export const QueryConsumerValidatorsValidator: MessageFns<QueryConsumerValidatorsValidator> = {
  encode(message: QueryConsumerValidatorsValidator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerAddress !== "") {
      writer.uint32(10).string(message.providerAddress);
    }
    if (message.consumerKey !== undefined) {
      PublicKey.encode(message.consumerKey, writer.uint32(18).fork()).join();
    }
    if (message.power !== "0") {
      writer.uint32(24).int64(message.power);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryConsumerValidatorsValidator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryConsumerValidatorsValidator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.consumerKey = PublicKey.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.power = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryConsumerValidatorsValidator {
    return {
      providerAddress: isSet(object.providerAddress) ? globalThis.String(object.providerAddress) : "",
      consumerKey: isSet(object.consumerKey) ? PublicKey.fromJSON(object.consumerKey) : undefined,
      power: isSet(object.power) ? globalThis.String(object.power) : "0",
    };
  },

  toJSON(message: QueryConsumerValidatorsValidator): unknown {
    const obj: any = {};
    if (message.providerAddress !== "") {
      obj.providerAddress = message.providerAddress;
    }
    if (message.consumerKey !== undefined) {
      obj.consumerKey = PublicKey.toJSON(message.consumerKey);
    }
    if (message.power !== "0") {
      obj.power = message.power;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryConsumerValidatorsValidator>, I>>(
    base?: I,
  ): QueryConsumerValidatorsValidator {
    return QueryConsumerValidatorsValidator.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryConsumerValidatorsValidator>, I>>(
    object: I,
  ): QueryConsumerValidatorsValidator {
    const message = createBaseQueryConsumerValidatorsValidator();
    message.providerAddress = object.providerAddress ?? "";
    message.consumerKey = (object.consumerKey !== undefined && object.consumerKey !== null)
      ? PublicKey.fromPartial(object.consumerKey)
      : undefined;
    message.power = object.power ?? "0";
    return message;
  },
};

function createBaseQueryConsumerValidatorsResponse(): QueryConsumerValidatorsResponse {
  return { validators: [] };
}

export const QueryConsumerValidatorsResponse: MessageFns<QueryConsumerValidatorsResponse> = {
  encode(message: QueryConsumerValidatorsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.validators) {
      QueryConsumerValidatorsValidator.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryConsumerValidatorsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryConsumerValidatorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validators.push(QueryConsumerValidatorsValidator.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryConsumerValidatorsResponse {
    return {
      validators: globalThis.Array.isArray(object?.validators)
        ? object.validators.map((e: any) => QueryConsumerValidatorsValidator.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryConsumerValidatorsResponse): unknown {
    const obj: any = {};
    if (message.validators?.length) {
      obj.validators = message.validators.map((e) => QueryConsumerValidatorsValidator.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryConsumerValidatorsResponse>, I>>(base?: I): QueryConsumerValidatorsResponse {
    return QueryConsumerValidatorsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryConsumerValidatorsResponse>, I>>(
    object: I,
  ): QueryConsumerValidatorsResponse {
    const message = createBaseQueryConsumerValidatorsResponse();
    message.validators = object.validators?.map((e) => QueryConsumerValidatorsValidator.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryConsumerChainsValidatorHasToValidateRequest(): QueryConsumerChainsValidatorHasToValidateRequest {
  return { providerAddress: "" };
}

export const QueryConsumerChainsValidatorHasToValidateRequest: MessageFns<
  QueryConsumerChainsValidatorHasToValidateRequest
> = {
  encode(
    message: QueryConsumerChainsValidatorHasToValidateRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.providerAddress !== "") {
      writer.uint32(10).string(message.providerAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryConsumerChainsValidatorHasToValidateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryConsumerChainsValidatorHasToValidateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryConsumerChainsValidatorHasToValidateRequest {
    return { providerAddress: isSet(object.providerAddress) ? globalThis.String(object.providerAddress) : "" };
  },

  toJSON(message: QueryConsumerChainsValidatorHasToValidateRequest): unknown {
    const obj: any = {};
    if (message.providerAddress !== "") {
      obj.providerAddress = message.providerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryConsumerChainsValidatorHasToValidateRequest>, I>>(
    base?: I,
  ): QueryConsumerChainsValidatorHasToValidateRequest {
    return QueryConsumerChainsValidatorHasToValidateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryConsumerChainsValidatorHasToValidateRequest>, I>>(
    object: I,
  ): QueryConsumerChainsValidatorHasToValidateRequest {
    const message = createBaseQueryConsumerChainsValidatorHasToValidateRequest();
    message.providerAddress = object.providerAddress ?? "";
    return message;
  },
};

function createBaseQueryConsumerChainsValidatorHasToValidateResponse(): QueryConsumerChainsValidatorHasToValidateResponse {
  return { consumerChainIds: [] };
}

export const QueryConsumerChainsValidatorHasToValidateResponse: MessageFns<
  QueryConsumerChainsValidatorHasToValidateResponse
> = {
  encode(
    message: QueryConsumerChainsValidatorHasToValidateResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.consumerChainIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryConsumerChainsValidatorHasToValidateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryConsumerChainsValidatorHasToValidateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consumerChainIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryConsumerChainsValidatorHasToValidateResponse {
    return {
      consumerChainIds: globalThis.Array.isArray(object?.consumerChainIds)
        ? object.consumerChainIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: QueryConsumerChainsValidatorHasToValidateResponse): unknown {
    const obj: any = {};
    if (message.consumerChainIds?.length) {
      obj.consumerChainIds = message.consumerChainIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryConsumerChainsValidatorHasToValidateResponse>, I>>(
    base?: I,
  ): QueryConsumerChainsValidatorHasToValidateResponse {
    return QueryConsumerChainsValidatorHasToValidateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryConsumerChainsValidatorHasToValidateResponse>, I>>(
    object: I,
  ): QueryConsumerChainsValidatorHasToValidateResponse {
    const message = createBaseQueryConsumerChainsValidatorHasToValidateResponse();
    message.consumerChainIds = object.consumerChainIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryValidatorConsumerCommissionRateRequest(): QueryValidatorConsumerCommissionRateRequest {
  return { chainId: "", providerAddress: "" };
}

export const QueryValidatorConsumerCommissionRateRequest: MessageFns<QueryValidatorConsumerCommissionRateRequest> = {
  encode(
    message: QueryValidatorConsumerCommissionRateRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.providerAddress !== "") {
      writer.uint32(18).string(message.providerAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryValidatorConsumerCommissionRateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidatorConsumerCommissionRateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidatorConsumerCommissionRateRequest {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      providerAddress: isSet(object.providerAddress) ? globalThis.String(object.providerAddress) : "",
    };
  },

  toJSON(message: QueryValidatorConsumerCommissionRateRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.providerAddress !== "") {
      obj.providerAddress = message.providerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryValidatorConsumerCommissionRateRequest>, I>>(
    base?: I,
  ): QueryValidatorConsumerCommissionRateRequest {
    return QueryValidatorConsumerCommissionRateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryValidatorConsumerCommissionRateRequest>, I>>(
    object: I,
  ): QueryValidatorConsumerCommissionRateRequest {
    const message = createBaseQueryValidatorConsumerCommissionRateRequest();
    message.chainId = object.chainId ?? "";
    message.providerAddress = object.providerAddress ?? "";
    return message;
  },
};

function createBaseQueryValidatorConsumerCommissionRateResponse(): QueryValidatorConsumerCommissionRateResponse {
  return { rate: "" };
}

export const QueryValidatorConsumerCommissionRateResponse: MessageFns<QueryValidatorConsumerCommissionRateResponse> = {
  encode(
    message: QueryValidatorConsumerCommissionRateResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.rate !== "") {
      writer.uint32(10).string(message.rate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryValidatorConsumerCommissionRateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidatorConsumerCommissionRateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidatorConsumerCommissionRateResponse {
    return { rate: isSet(object.rate) ? globalThis.String(object.rate) : "" };
  },

  toJSON(message: QueryValidatorConsumerCommissionRateResponse): unknown {
    const obj: any = {};
    if (message.rate !== "") {
      obj.rate = message.rate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryValidatorConsumerCommissionRateResponse>, I>>(
    base?: I,
  ): QueryValidatorConsumerCommissionRateResponse {
    return QueryValidatorConsumerCommissionRateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryValidatorConsumerCommissionRateResponse>, I>>(
    object: I,
  ): QueryValidatorConsumerCommissionRateResponse {
    const message = createBaseQueryValidatorConsumerCommissionRateResponse();
    message.rate = object.rate ?? "";
    return message;
  },
};

function createBaseQueryOldestUnconfirmedVscRequest(): QueryOldestUnconfirmedVscRequest {
  return { chainId: "" };
}

export const QueryOldestUnconfirmedVscRequest: MessageFns<QueryOldestUnconfirmedVscRequest> = {
  encode(message: QueryOldestUnconfirmedVscRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOldestUnconfirmedVscRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOldestUnconfirmedVscRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOldestUnconfirmedVscRequest {
    return { chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "" };
  },

  toJSON(message: QueryOldestUnconfirmedVscRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOldestUnconfirmedVscRequest>, I>>(
    base?: I,
  ): QueryOldestUnconfirmedVscRequest {
    return QueryOldestUnconfirmedVscRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOldestUnconfirmedVscRequest>, I>>(
    object: I,
  ): QueryOldestUnconfirmedVscRequest {
    const message = createBaseQueryOldestUnconfirmedVscRequest();
    message.chainId = object.chainId ?? "";
    return message;
  },
};

function createBaseQueryOldestUnconfirmedVscResponse(): QueryOldestUnconfirmedVscResponse {
  return { vscSendTimestamp: undefined };
}

export const QueryOldestUnconfirmedVscResponse: MessageFns<QueryOldestUnconfirmedVscResponse> = {
  encode(message: QueryOldestUnconfirmedVscResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vscSendTimestamp !== undefined) {
      VscSendTimestamp.encode(message.vscSendTimestamp, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOldestUnconfirmedVscResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOldestUnconfirmedVscResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vscSendTimestamp = VscSendTimestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOldestUnconfirmedVscResponse {
    return {
      vscSendTimestamp: isSet(object.vscSendTimestamp) ? VscSendTimestamp.fromJSON(object.vscSendTimestamp) : undefined,
    };
  },

  toJSON(message: QueryOldestUnconfirmedVscResponse): unknown {
    const obj: any = {};
    if (message.vscSendTimestamp !== undefined) {
      obj.vscSendTimestamp = VscSendTimestamp.toJSON(message.vscSendTimestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOldestUnconfirmedVscResponse>, I>>(
    base?: I,
  ): QueryOldestUnconfirmedVscResponse {
    return QueryOldestUnconfirmedVscResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOldestUnconfirmedVscResponse>, I>>(
    object: I,
  ): QueryOldestUnconfirmedVscResponse {
    const message = createBaseQueryOldestUnconfirmedVscResponse();
    message.vscSendTimestamp = (object.vscSendTimestamp !== undefined && object.vscSendTimestamp !== null)
      ? VscSendTimestamp.fromPartial(object.vscSendTimestamp)
      : undefined;
    return message;
  },
};

export type QueryService = typeof QueryService;
export const QueryService = {
  /**
   * ConsumerGenesis queries the genesis state needed to start a consumer chain
   * whose proposal has been accepted
   */
  queryConsumerGenesis: {
    path: "/interchain_security.ccv.provider.v1.Query/QueryConsumerGenesis",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryConsumerGenesisRequest) =>
      Buffer.from(QueryConsumerGenesisRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryConsumerGenesisRequest.decode(value),
    responseSerialize: (value: QueryConsumerGenesisResponse) =>
      Buffer.from(QueryConsumerGenesisResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryConsumerGenesisResponse.decode(value),
  },
  /**
   * ConsumerChains queries active consumer chains supported by the provider
   * chain
   */
  queryConsumerChains: {
    path: "/interchain_security.ccv.provider.v1.Query/QueryConsumerChains",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryConsumerChainsRequest) =>
      Buffer.from(QueryConsumerChainsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryConsumerChainsRequest.decode(value),
    responseSerialize: (value: QueryConsumerChainsResponse) =>
      Buffer.from(QueryConsumerChainsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryConsumerChainsResponse.decode(value),
  },
  /** QueryConsumerChainStarts queries consumer chain start proposals. */
  queryConsumerChainStarts: {
    path: "/interchain_security.ccv.provider.v1.Query/QueryConsumerChainStarts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryConsumerChainStartProposalsRequest) =>
      Buffer.from(QueryConsumerChainStartProposalsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryConsumerChainStartProposalsRequest.decode(value),
    responseSerialize: (value: QueryConsumerChainStartProposalsResponse) =>
      Buffer.from(QueryConsumerChainStartProposalsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryConsumerChainStartProposalsResponse.decode(value),
  },
  /** QueryConsumerChainStops queries consumer chain stop proposals. */
  queryConsumerChainStops: {
    path: "/interchain_security.ccv.provider.v1.Query/QueryConsumerChainStops",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryConsumerChainStopProposalsRequest) =>
      Buffer.from(QueryConsumerChainStopProposalsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryConsumerChainStopProposalsRequest.decode(value),
    responseSerialize: (value: QueryConsumerChainStopProposalsResponse) =>
      Buffer.from(QueryConsumerChainStopProposalsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryConsumerChainStopProposalsResponse.decode(value),
  },
  /**
   * QueryValidatorConsumerAddr queries the address
   * assigned by a validator for a consumer chain.
   */
  queryValidatorConsumerAddr: {
    path: "/interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerAddr",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryValidatorConsumerAddrRequest) =>
      Buffer.from(QueryValidatorConsumerAddrRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryValidatorConsumerAddrRequest.decode(value),
    responseSerialize: (value: QueryValidatorConsumerAddrResponse) =>
      Buffer.from(QueryValidatorConsumerAddrResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryValidatorConsumerAddrResponse.decode(value),
  },
  /**
   * QueryProviderAddr returns the provider chain validator
   * given a consumer chain validator address
   */
  queryValidatorProviderAddr: {
    path: "/interchain_security.ccv.provider.v1.Query/QueryValidatorProviderAddr",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryValidatorProviderAddrRequest) =>
      Buffer.from(QueryValidatorProviderAddrRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryValidatorProviderAddrRequest.decode(value),
    responseSerialize: (value: QueryValidatorProviderAddrResponse) =>
      Buffer.from(QueryValidatorProviderAddrResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryValidatorProviderAddrResponse.decode(value),
  },
  /**
   * QueryThrottleState returns the main on-chain state relevant to currently
   * throttled slash packets
   */
  queryThrottleState: {
    path: "/interchain_security.ccv.provider.v1.Query/QueryThrottleState",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryThrottleStateRequest) =>
      Buffer.from(QueryThrottleStateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryThrottleStateRequest.decode(value),
    responseSerialize: (value: QueryThrottleStateResponse) =>
      Buffer.from(QueryThrottleStateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryThrottleStateResponse.decode(value),
  },
  /**
   * QueryRegisteredConsumerRewardDenoms returns a list of consumer reward
   * denoms that are registered
   */
  queryRegisteredConsumerRewardDenoms: {
    path: "/interchain_security.ccv.provider.v1.Query/QueryRegisteredConsumerRewardDenoms",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryRegisteredConsumerRewardDenomsRequest) =>
      Buffer.from(QueryRegisteredConsumerRewardDenomsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryRegisteredConsumerRewardDenomsRequest.decode(value),
    responseSerialize: (value: QueryRegisteredConsumerRewardDenomsResponse) =>
      Buffer.from(QueryRegisteredConsumerRewardDenomsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryRegisteredConsumerRewardDenomsResponse.decode(value),
  },
  /**
   * QueryProposedConsumerChainIDs returns the chain IDs of the proposed consumer chain addition proposals
   * that are still in the voting period
   */
  queryProposedConsumerChainIDs: {
    path: "/interchain_security.ccv.provider.v1.Query/QueryProposedConsumerChainIDs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryProposedChainIDsRequest) =>
      Buffer.from(QueryProposedChainIDsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryProposedChainIDsRequest.decode(value),
    responseSerialize: (value: QueryProposedChainIDsResponse) =>
      Buffer.from(QueryProposedChainIDsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryProposedChainIDsResponse.decode(value),
  },
  /**
   * QueryAllPairsValConAddrByConsumerChainID returns a list of pair valconsensus address
   * between provider and consumer chain
   */
  queryAllPairsValConAddrByConsumerChainId: {
    path: "/interchain_security.ccv.provider.v1.Query/QueryAllPairsValConAddrByConsumerChainID",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryAllPairsValConAddrByConsumerChainIDRequest) =>
      Buffer.from(QueryAllPairsValConAddrByConsumerChainIDRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryAllPairsValConAddrByConsumerChainIDRequest.decode(value),
    responseSerialize: (value: QueryAllPairsValConAddrByConsumerChainIDResponse) =>
      Buffer.from(QueryAllPairsValConAddrByConsumerChainIDResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryAllPairsValConAddrByConsumerChainIDResponse.decode(value),
  },
  /** QueryParams returns all current values of provider parameters */
  queryParams: {
    path: "/interchain_security.ccv.provider.v1.Query/QueryParams",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryParamsRequest) => Buffer.from(QueryParamsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryParamsRequest.decode(value),
    responseSerialize: (value: QueryParamsResponse) => Buffer.from(QueryParamsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryParamsResponse.decode(value),
  },
  /**
   * QueryConsumerChainOptedInValidators returns a list of validators consensus addresses
   * that opted-in to the given consumer chain
   */
  queryConsumerChainOptedInValidators: {
    path: "/interchain_security.ccv.provider.v1.Query/QueryConsumerChainOptedInValidators",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryConsumerChainOptedInValidatorsRequest) =>
      Buffer.from(QueryConsumerChainOptedInValidatorsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryConsumerChainOptedInValidatorsRequest.decode(value),
    responseSerialize: (value: QueryConsumerChainOptedInValidatorsResponse) =>
      Buffer.from(QueryConsumerChainOptedInValidatorsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryConsumerChainOptedInValidatorsResponse.decode(value),
  },
  /**
   * QueryConsumerChainsValidatorHasToValidate returns a list of consumer chains
   * that a given validator must validate
   */
  queryConsumerChainsValidatorHasToValidate: {
    path: "/interchain_security.ccv.provider.v1.Query/QueryConsumerChainsValidatorHasToValidate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryConsumerChainsValidatorHasToValidateRequest) =>
      Buffer.from(QueryConsumerChainsValidatorHasToValidateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryConsumerChainsValidatorHasToValidateRequest.decode(value),
    responseSerialize: (value: QueryConsumerChainsValidatorHasToValidateResponse) =>
      Buffer.from(QueryConsumerChainsValidatorHasToValidateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryConsumerChainsValidatorHasToValidateResponse.decode(value),
  },
  /**
   * QueryValidatorConsumerCommissionRate returns the commission rate a given
   * validator charges on a given consumer chain
   */
  queryValidatorConsumerCommissionRate: {
    path: "/interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerCommissionRate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryValidatorConsumerCommissionRateRequest) =>
      Buffer.from(QueryValidatorConsumerCommissionRateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryValidatorConsumerCommissionRateRequest.decode(value),
    responseSerialize: (value: QueryValidatorConsumerCommissionRateResponse) =>
      Buffer.from(QueryValidatorConsumerCommissionRateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryValidatorConsumerCommissionRateResponse.decode(value),
  },
  /** QueryOldestUnconfirmedVsc returns the send timestamp of the oldest unconfirmed VSCPacket for a given chainID */
  queryOldestUnconfirmedVsc: {
    path: "/interchain_security.ccv.provider.v1.Query/QueryOldestUnconfirmedVsc",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryOldestUnconfirmedVscRequest) =>
      Buffer.from(QueryOldestUnconfirmedVscRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryOldestUnconfirmedVscRequest.decode(value),
    responseSerialize: (value: QueryOldestUnconfirmedVscResponse) =>
      Buffer.from(QueryOldestUnconfirmedVscResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryOldestUnconfirmedVscResponse.decode(value),
  },
  /**
   * QueryConsumerValidators returns the latest set consumer-validator set for a given chainID
   * Note that this does not necessarily mean that the consumer chain is using this validator set at this exact moment
   * because a VSCPacket could be delayed to be delivered on the consumer chain.
   */
  queryConsumerValidators: {
    path: "/interchain_security.ccv.provider.v1.Query/QueryConsumerValidators",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryConsumerValidatorsRequest) =>
      Buffer.from(QueryConsumerValidatorsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryConsumerValidatorsRequest.decode(value),
    responseSerialize: (value: QueryConsumerValidatorsResponse) =>
      Buffer.from(QueryConsumerValidatorsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryConsumerValidatorsResponse.decode(value),
  },
} as const;

export interface QueryServer extends UntypedServiceImplementation {
  /**
   * ConsumerGenesis queries the genesis state needed to start a consumer chain
   * whose proposal has been accepted
   */
  queryConsumerGenesis: handleUnaryCall<QueryConsumerGenesisRequest, QueryConsumerGenesisResponse>;
  /**
   * ConsumerChains queries active consumer chains supported by the provider
   * chain
   */
  queryConsumerChains: handleUnaryCall<QueryConsumerChainsRequest, QueryConsumerChainsResponse>;
  /** QueryConsumerChainStarts queries consumer chain start proposals. */
  queryConsumerChainStarts: handleUnaryCall<
    QueryConsumerChainStartProposalsRequest,
    QueryConsumerChainStartProposalsResponse
  >;
  /** QueryConsumerChainStops queries consumer chain stop proposals. */
  queryConsumerChainStops: handleUnaryCall<
    QueryConsumerChainStopProposalsRequest,
    QueryConsumerChainStopProposalsResponse
  >;
  /**
   * QueryValidatorConsumerAddr queries the address
   * assigned by a validator for a consumer chain.
   */
  queryValidatorConsumerAddr: handleUnaryCall<QueryValidatorConsumerAddrRequest, QueryValidatorConsumerAddrResponse>;
  /**
   * QueryProviderAddr returns the provider chain validator
   * given a consumer chain validator address
   */
  queryValidatorProviderAddr: handleUnaryCall<QueryValidatorProviderAddrRequest, QueryValidatorProviderAddrResponse>;
  /**
   * QueryThrottleState returns the main on-chain state relevant to currently
   * throttled slash packets
   */
  queryThrottleState: handleUnaryCall<QueryThrottleStateRequest, QueryThrottleStateResponse>;
  /**
   * QueryRegisteredConsumerRewardDenoms returns a list of consumer reward
   * denoms that are registered
   */
  queryRegisteredConsumerRewardDenoms: handleUnaryCall<
    QueryRegisteredConsumerRewardDenomsRequest,
    QueryRegisteredConsumerRewardDenomsResponse
  >;
  /**
   * QueryProposedConsumerChainIDs returns the chain IDs of the proposed consumer chain addition proposals
   * that are still in the voting period
   */
  queryProposedConsumerChainIDs: handleUnaryCall<QueryProposedChainIDsRequest, QueryProposedChainIDsResponse>;
  /**
   * QueryAllPairsValConAddrByConsumerChainID returns a list of pair valconsensus address
   * between provider and consumer chain
   */
  queryAllPairsValConAddrByConsumerChainId: handleUnaryCall<
    QueryAllPairsValConAddrByConsumerChainIDRequest,
    QueryAllPairsValConAddrByConsumerChainIDResponse
  >;
  /** QueryParams returns all current values of provider parameters */
  queryParams: handleUnaryCall<QueryParamsRequest, QueryParamsResponse>;
  /**
   * QueryConsumerChainOptedInValidators returns a list of validators consensus addresses
   * that opted-in to the given consumer chain
   */
  queryConsumerChainOptedInValidators: handleUnaryCall<
    QueryConsumerChainOptedInValidatorsRequest,
    QueryConsumerChainOptedInValidatorsResponse
  >;
  /**
   * QueryConsumerChainsValidatorHasToValidate returns a list of consumer chains
   * that a given validator must validate
   */
  queryConsumerChainsValidatorHasToValidate: handleUnaryCall<
    QueryConsumerChainsValidatorHasToValidateRequest,
    QueryConsumerChainsValidatorHasToValidateResponse
  >;
  /**
   * QueryValidatorConsumerCommissionRate returns the commission rate a given
   * validator charges on a given consumer chain
   */
  queryValidatorConsumerCommissionRate: handleUnaryCall<
    QueryValidatorConsumerCommissionRateRequest,
    QueryValidatorConsumerCommissionRateResponse
  >;
  /** QueryOldestUnconfirmedVsc returns the send timestamp of the oldest unconfirmed VSCPacket for a given chainID */
  queryOldestUnconfirmedVsc: handleUnaryCall<QueryOldestUnconfirmedVscRequest, QueryOldestUnconfirmedVscResponse>;
  /**
   * QueryConsumerValidators returns the latest set consumer-validator set for a given chainID
   * Note that this does not necessarily mean that the consumer chain is using this validator set at this exact moment
   * because a VSCPacket could be delayed to be delivered on the consumer chain.
   */
  queryConsumerValidators: handleUnaryCall<QueryConsumerValidatorsRequest, QueryConsumerValidatorsResponse>;
}

export interface QueryClient extends Client {
  /**
   * ConsumerGenesis queries the genesis state needed to start a consumer chain
   * whose proposal has been accepted
   */
  queryConsumerGenesis(
    request: QueryConsumerGenesisRequest,
    callback: (error: ServiceError | null, response: QueryConsumerGenesisResponse) => void,
  ): ClientUnaryCall;
  queryConsumerGenesis(
    request: QueryConsumerGenesisRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryConsumerGenesisResponse) => void,
  ): ClientUnaryCall;
  queryConsumerGenesis(
    request: QueryConsumerGenesisRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryConsumerGenesisResponse) => void,
  ): ClientUnaryCall;
  /**
   * ConsumerChains queries active consumer chains supported by the provider
   * chain
   */
  queryConsumerChains(
    request: QueryConsumerChainsRequest,
    callback: (error: ServiceError | null, response: QueryConsumerChainsResponse) => void,
  ): ClientUnaryCall;
  queryConsumerChains(
    request: QueryConsumerChainsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryConsumerChainsResponse) => void,
  ): ClientUnaryCall;
  queryConsumerChains(
    request: QueryConsumerChainsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryConsumerChainsResponse) => void,
  ): ClientUnaryCall;
  /** QueryConsumerChainStarts queries consumer chain start proposals. */
  queryConsumerChainStarts(
    request: QueryConsumerChainStartProposalsRequest,
    callback: (error: ServiceError | null, response: QueryConsumerChainStartProposalsResponse) => void,
  ): ClientUnaryCall;
  queryConsumerChainStarts(
    request: QueryConsumerChainStartProposalsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryConsumerChainStartProposalsResponse) => void,
  ): ClientUnaryCall;
  queryConsumerChainStarts(
    request: QueryConsumerChainStartProposalsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryConsumerChainStartProposalsResponse) => void,
  ): ClientUnaryCall;
  /** QueryConsumerChainStops queries consumer chain stop proposals. */
  queryConsumerChainStops(
    request: QueryConsumerChainStopProposalsRequest,
    callback: (error: ServiceError | null, response: QueryConsumerChainStopProposalsResponse) => void,
  ): ClientUnaryCall;
  queryConsumerChainStops(
    request: QueryConsumerChainStopProposalsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryConsumerChainStopProposalsResponse) => void,
  ): ClientUnaryCall;
  queryConsumerChainStops(
    request: QueryConsumerChainStopProposalsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryConsumerChainStopProposalsResponse) => void,
  ): ClientUnaryCall;
  /**
   * QueryValidatorConsumerAddr queries the address
   * assigned by a validator for a consumer chain.
   */
  queryValidatorConsumerAddr(
    request: QueryValidatorConsumerAddrRequest,
    callback: (error: ServiceError | null, response: QueryValidatorConsumerAddrResponse) => void,
  ): ClientUnaryCall;
  queryValidatorConsumerAddr(
    request: QueryValidatorConsumerAddrRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryValidatorConsumerAddrResponse) => void,
  ): ClientUnaryCall;
  queryValidatorConsumerAddr(
    request: QueryValidatorConsumerAddrRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryValidatorConsumerAddrResponse) => void,
  ): ClientUnaryCall;
  /**
   * QueryProviderAddr returns the provider chain validator
   * given a consumer chain validator address
   */
  queryValidatorProviderAddr(
    request: QueryValidatorProviderAddrRequest,
    callback: (error: ServiceError | null, response: QueryValidatorProviderAddrResponse) => void,
  ): ClientUnaryCall;
  queryValidatorProviderAddr(
    request: QueryValidatorProviderAddrRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryValidatorProviderAddrResponse) => void,
  ): ClientUnaryCall;
  queryValidatorProviderAddr(
    request: QueryValidatorProviderAddrRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryValidatorProviderAddrResponse) => void,
  ): ClientUnaryCall;
  /**
   * QueryThrottleState returns the main on-chain state relevant to currently
   * throttled slash packets
   */
  queryThrottleState(
    request: QueryThrottleStateRequest,
    callback: (error: ServiceError | null, response: QueryThrottleStateResponse) => void,
  ): ClientUnaryCall;
  queryThrottleState(
    request: QueryThrottleStateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryThrottleStateResponse) => void,
  ): ClientUnaryCall;
  queryThrottleState(
    request: QueryThrottleStateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryThrottleStateResponse) => void,
  ): ClientUnaryCall;
  /**
   * QueryRegisteredConsumerRewardDenoms returns a list of consumer reward
   * denoms that are registered
   */
  queryRegisteredConsumerRewardDenoms(
    request: QueryRegisteredConsumerRewardDenomsRequest,
    callback: (error: ServiceError | null, response: QueryRegisteredConsumerRewardDenomsResponse) => void,
  ): ClientUnaryCall;
  queryRegisteredConsumerRewardDenoms(
    request: QueryRegisteredConsumerRewardDenomsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryRegisteredConsumerRewardDenomsResponse) => void,
  ): ClientUnaryCall;
  queryRegisteredConsumerRewardDenoms(
    request: QueryRegisteredConsumerRewardDenomsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryRegisteredConsumerRewardDenomsResponse) => void,
  ): ClientUnaryCall;
  /**
   * QueryProposedConsumerChainIDs returns the chain IDs of the proposed consumer chain addition proposals
   * that are still in the voting period
   */
  queryProposedConsumerChainIDs(
    request: QueryProposedChainIDsRequest,
    callback: (error: ServiceError | null, response: QueryProposedChainIDsResponse) => void,
  ): ClientUnaryCall;
  queryProposedConsumerChainIDs(
    request: QueryProposedChainIDsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryProposedChainIDsResponse) => void,
  ): ClientUnaryCall;
  queryProposedConsumerChainIDs(
    request: QueryProposedChainIDsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryProposedChainIDsResponse) => void,
  ): ClientUnaryCall;
  /**
   * QueryAllPairsValConAddrByConsumerChainID returns a list of pair valconsensus address
   * between provider and consumer chain
   */
  queryAllPairsValConAddrByConsumerChainId(
    request: QueryAllPairsValConAddrByConsumerChainIDRequest,
    callback: (error: ServiceError | null, response: QueryAllPairsValConAddrByConsumerChainIDResponse) => void,
  ): ClientUnaryCall;
  queryAllPairsValConAddrByConsumerChainId(
    request: QueryAllPairsValConAddrByConsumerChainIDRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryAllPairsValConAddrByConsumerChainIDResponse) => void,
  ): ClientUnaryCall;
  queryAllPairsValConAddrByConsumerChainId(
    request: QueryAllPairsValConAddrByConsumerChainIDRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryAllPairsValConAddrByConsumerChainIDResponse) => void,
  ): ClientUnaryCall;
  /** QueryParams returns all current values of provider parameters */
  queryParams(
    request: QueryParamsRequest,
    callback: (error: ServiceError | null, response: QueryParamsResponse) => void,
  ): ClientUnaryCall;
  queryParams(
    request: QueryParamsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryParamsResponse) => void,
  ): ClientUnaryCall;
  queryParams(
    request: QueryParamsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryParamsResponse) => void,
  ): ClientUnaryCall;
  /**
   * QueryConsumerChainOptedInValidators returns a list of validators consensus addresses
   * that opted-in to the given consumer chain
   */
  queryConsumerChainOptedInValidators(
    request: QueryConsumerChainOptedInValidatorsRequest,
    callback: (error: ServiceError | null, response: QueryConsumerChainOptedInValidatorsResponse) => void,
  ): ClientUnaryCall;
  queryConsumerChainOptedInValidators(
    request: QueryConsumerChainOptedInValidatorsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryConsumerChainOptedInValidatorsResponse) => void,
  ): ClientUnaryCall;
  queryConsumerChainOptedInValidators(
    request: QueryConsumerChainOptedInValidatorsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryConsumerChainOptedInValidatorsResponse) => void,
  ): ClientUnaryCall;
  /**
   * QueryConsumerChainsValidatorHasToValidate returns a list of consumer chains
   * that a given validator must validate
   */
  queryConsumerChainsValidatorHasToValidate(
    request: QueryConsumerChainsValidatorHasToValidateRequest,
    callback: (error: ServiceError | null, response: QueryConsumerChainsValidatorHasToValidateResponse) => void,
  ): ClientUnaryCall;
  queryConsumerChainsValidatorHasToValidate(
    request: QueryConsumerChainsValidatorHasToValidateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryConsumerChainsValidatorHasToValidateResponse) => void,
  ): ClientUnaryCall;
  queryConsumerChainsValidatorHasToValidate(
    request: QueryConsumerChainsValidatorHasToValidateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryConsumerChainsValidatorHasToValidateResponse) => void,
  ): ClientUnaryCall;
  /**
   * QueryValidatorConsumerCommissionRate returns the commission rate a given
   * validator charges on a given consumer chain
   */
  queryValidatorConsumerCommissionRate(
    request: QueryValidatorConsumerCommissionRateRequest,
    callback: (error: ServiceError | null, response: QueryValidatorConsumerCommissionRateResponse) => void,
  ): ClientUnaryCall;
  queryValidatorConsumerCommissionRate(
    request: QueryValidatorConsumerCommissionRateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryValidatorConsumerCommissionRateResponse) => void,
  ): ClientUnaryCall;
  queryValidatorConsumerCommissionRate(
    request: QueryValidatorConsumerCommissionRateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryValidatorConsumerCommissionRateResponse) => void,
  ): ClientUnaryCall;
  /** QueryOldestUnconfirmedVsc returns the send timestamp of the oldest unconfirmed VSCPacket for a given chainID */
  queryOldestUnconfirmedVsc(
    request: QueryOldestUnconfirmedVscRequest,
    callback: (error: ServiceError | null, response: QueryOldestUnconfirmedVscResponse) => void,
  ): ClientUnaryCall;
  queryOldestUnconfirmedVsc(
    request: QueryOldestUnconfirmedVscRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryOldestUnconfirmedVscResponse) => void,
  ): ClientUnaryCall;
  queryOldestUnconfirmedVsc(
    request: QueryOldestUnconfirmedVscRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryOldestUnconfirmedVscResponse) => void,
  ): ClientUnaryCall;
  /**
   * QueryConsumerValidators returns the latest set consumer-validator set for a given chainID
   * Note that this does not necessarily mean that the consumer chain is using this validator set at this exact moment
   * because a VSCPacket could be delayed to be delivered on the consumer chain.
   */
  queryConsumerValidators(
    request: QueryConsumerValidatorsRequest,
    callback: (error: ServiceError | null, response: QueryConsumerValidatorsResponse) => void,
  ): ClientUnaryCall;
  queryConsumerValidators(
    request: QueryConsumerValidatorsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryConsumerValidatorsResponse) => void,
  ): ClientUnaryCall;
  queryConsumerValidators(
    request: QueryConsumerValidatorsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryConsumerValidatorsResponse) => void,
  ): ClientUnaryCall;
}

export const QueryClient = makeGenericClientConstructor(
  QueryService,
  "interchain_security.ccv.provider.v1.Query",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): QueryClient;
  service: typeof QueryService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
