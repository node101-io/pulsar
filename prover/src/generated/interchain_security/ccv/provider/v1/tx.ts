// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: interchain_security/ccv/provider/v1/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Duration } from "../../../../google/protobuf/duration.js";
import { Timestamp } from "../../../../google/protobuf/timestamp.js";
import { Height } from "../../../../ibc/core/client/v1/client.js";
import { Header, Misbehaviour } from "../../../../ibc/lightclients/tendermint/v1/tendermint.js";
import { DuplicateVoteEvidence } from "../../../../tendermint/types/evidence.js";
import { Params } from "./provider.js";

export const protobufPackage = "interchain_security.ccv.provider.v1";

export interface MsgAssignConsumerKey {
  /** The chain id of the consumer chain to assign a consensus public key to */
  chainId: string;
  /** The validator address on the provider */
  providerAddr: string;
  /**
   * The consensus public key to use on the consumer.
   * in json string format corresponding to proto-any, ex:
   * `{"@type":"/cosmos.crypto.ed25519.PubKey","key":"Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is="}`
   */
  consumerKey: string;
  /** Tx signer address */
  signer: string;
}

export interface MsgAssignConsumerKeyResponse {
}

/**
 * MsgSubmitConsumerMisbehaviour defines a message that reports a light client attack,
 * also known as a misbehaviour, observed on a consumer chain
 */
export interface MsgSubmitConsumerMisbehaviour {
  submitter: string;
  /**
   * The Misbehaviour of the consumer chain wrapping
   * two conflicting IBC headers
   */
  misbehaviour?: Misbehaviour | undefined;
}

export interface MsgSubmitConsumerMisbehaviourResponse {
}

/**
 * MsgSubmitConsumerDoubleVoting defines a message that reports
 * a double signing infraction observed on a consumer chain
 */
export interface MsgSubmitConsumerDoubleVoting {
  submitter: string;
  /**
   * The equivocation of the consumer chain wrapping
   * an evidence of a validator that signed two conflicting votes
   */
  duplicateVoteEvidence?:
    | DuplicateVoteEvidence
    | undefined;
  /** The light client header of the infraction block */
  infractionBlockHeader?: Header | undefined;
}

export interface MsgSubmitConsumerDoubleVotingResponse {
}

/** MsgUpdateParams is the Msg/UpdateParams request type */
export interface MsgUpdateParams {
  /** signer is the address of the governance account. */
  authority: string;
  /** params defines the x/provider parameters to update. */
  params?: Params | undefined;
}

export interface MsgUpdateParamsResponse {
}

/**
 * MsgConsumerAddition defines the message used to spawn a new consumer chain using a v1 governance proposal.
 * If it passes, then all validators on the provider chain are expected to validate
 * the consumer chain at spawn time or get slashed.
 * It is recommended that spawn time occurs after the proposal end time.
 *
 * Note: this replaces ConsumerAdditionProposal which is deprecated and will be removed soon
 */
export interface MsgConsumerAddition {
  /**
   * the proposed chain-id of the new consumer chain, must be different from all
   * other consumer chain ids of the executing provider chain.
   */
  chainId: string;
  /**
   * the proposed initial height of new consumer chain.
   * For a completely new chain, this will be {0,1}. However, it may be
   * different if this is a chain that is converting to a consumer chain.
   */
  initialHeight?:
    | Height
    | undefined;
  /**
   * The hash of the consumer chain genesis state without the consumer CCV
   * module genesis params. It is used for off-chain confirmation of
   * genesis.json validity by validators and other parties.
   */
  genesisHash: Buffer;
  /**
   * The hash of the consumer chain binary that should be run by validators on
   * chain initialization. It is used for off-chain confirmation of binary
   * validity by validators and other parties.
   */
  binaryHash: Buffer;
  /**
   * spawn time is the time on the provider chain at which the consumer chain
   * genesis is finalized and all validators will be responsible for starting
   * their consumer chain validator node.
   */
  spawnTime?:
    | Date
    | undefined;
  /**
   * Unbonding period for the consumer,
   * which should be smaller than that of the provider in general.
   */
  unbondingPeriod?:
    | Duration
    | undefined;
  /** Sent CCV related IBC packets will timeout after this duration */
  ccvTimeoutPeriod?:
    | Duration
    | undefined;
  /** Sent transfer related IBC packets will timeout after this duration */
  transferTimeoutPeriod?:
    | Duration
    | undefined;
  /**
   * The fraction of tokens allocated to the consumer redistribution address
   * during distribution events. The fraction is a string representing a
   * decimal number. For example "0.75" would represent 75%.
   */
  consumerRedistributionFraction: string;
  /**
   * BlocksPerDistributionTransmission is the number of blocks between
   * ibc-token-transfers from the consumer chain to the provider chain. On
   * sending transmission event, `consumer_redistribution_fraction` of the
   * accumulated tokens are sent to the consumer redistribution address.
   */
  blocksPerDistributionTransmission: string;
  /**
   * The number of historical info entries to persist in store.
   * This param is a part of the cosmos sdk staking module. In the case of
   * a ccv enabled consumer chain, the ccv module acts as the staking module.
   */
  historicalEntries: string;
  /**
   * The ID of a token transfer channel used for the Reward Distribution
   * sub-protocol. If DistributionTransmissionChannel == "", a new transfer
   * channel is created on top of the same connection as the CCV channel.
   * Note that transfer_channel_id is the ID of the channel end on the consumer
   * chain. it is most relevant for chains performing a sovereign to consumer
   * changeover in order to maintan the existing ibc transfer channel
   */
  distributionTransmissionChannel: string;
  /**
   * Corresponds to the percentage of validators that have to validate the chain under the Top N case.
   * For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power
   * have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100].
   * A chain can join with top_N == 0 as an Opt In chain, or with top_N âˆˆ [50, 100] as a Top N chain.
   */
  topN: number;
  /**
   * Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if
   * `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the
   * consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only
   * 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need
   * to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis.
   */
  validatorsPowerCap: number;
  /**
   * Corresponds to the maximum number of validators that can validate a consumer chain.
   * Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op.
   */
  validatorSetCap: number;
  /**
   * Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate
   * the consumer chain.
   */
  allowlist: string[];
  /** Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain. */
  denylist: string[];
  /** signer address */
  authority: string;
}

/** MsgConsumerAdditionResponse defines response type for MsgConsumerAddition messages */
export interface MsgConsumerAdditionResponse {
}

/**
 * MsgConsumerRemoval message contains a governance proposal on the provider chain to
 * remove (and stop) a consumer chain. If it passes, all the consumer chain's
 * state is removed from the provider chain. The outstanding unbonding operation
 * funds are released.
 *
 * Note: this replaces ConsumerRemovalProposal which is deprecated and will be removed soon
 */
export interface MsgConsumerRemoval {
  /** the chain-id of the consumer chain to be stopped */
  chainId: string;
  /**
   * the time on the provider chain at which all validators are responsible to
   * stop their consumer chain validator node
   */
  stopTime?:
    | Date
    | undefined;
  /** signer address */
  authority: string;
}

/** MsgConsumerRemovalResponse defines response type for MsgConsumerRemoval messages */
export interface MsgConsumerRemovalResponse {
}

/**
 * ChangeRewardDenomsProposal is a governance proposal on the provider chain to
 * mutate the set of denoms accepted by the provider as rewards.
 *
 * Note: this replaces ChangeRewardDenomsProposal which is deprecated and will be removed soon
 */
export interface MsgChangeRewardDenoms {
  /** the list of consumer reward denoms to add */
  denomsToAdd: string[];
  /** the list of consumer reward denoms to remove */
  denomsToRemove: string[];
  /** signer address */
  authority: string;
}

/** MsgChangeRewardDenomsResponse defines response type for MsgChangeRewardDenoms messages */
export interface MsgChangeRewardDenomsResponse {
}

export interface MsgOptIn {
  /** the chain id of the consumer chain to opt in to */
  chainId: string;
  /** the validator address on the provider */
  providerAddr: string;
  /**
   * (optional) The consensus public key to use on the consumer in json string format corresponding to proto-any,
   * for example `{"@type":"/cosmos.crypto.ed25519.PubKey","key":"Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is="}`.
   * This field is optional and can remain empty (i.e., `consumer_key = ""`). A validator can always change the
   * consumer public key at a later stage by issuing a `MsgAssignConsumerKey` message.
   */
  consumerKey: string;
  /** signer address */
  signer: string;
}

export interface MsgOptInResponse {
}

export interface MsgOptOut {
  /** the chain id of the consumer chain to opt out from */
  chainId: string;
  /** the validator address on the provider */
  providerAddr: string;
  /** signer address */
  signer: string;
}

export interface MsgOptOutResponse {
}

/**
 * MsgSetConsumerCommissionRate allows validators to set
 * a per-consumer chain commission rate
 */
export interface MsgSetConsumerCommissionRate {
  /** The validator address on the provider */
  providerAddr: string;
  /** The chain id of the consumer chain to set a commission rate */
  chainId: string;
  /**
   * The rate to charge delegators on the consumer chain, as a fraction
   * TODO: migrate rate from sdk.Dec to math.LegacyDec
   */
  rate: string;
  /** signer address */
  signer: string;
}

export interface MsgSetConsumerCommissionRateResponse {
}

/**
 * MsgConsumerModification message contains a governance proposal on the provider chain to
 * modify a running consumer chain. If it passes, the consumer chain's
 * parameters are updated.
 *
 * Note: this replaces ConsumerModificationProposal which is deprecated and will be removed soon
 */
export interface MsgConsumerModification {
  /** the title of the proposal */
  title: string;
  /** the description of the proposal */
  description: string;
  /** the chain-id of the consumer chain to be modified */
  chainId: string;
  /**
   * Corresponds to the percentage of validators that have to validate the chain under the Top N case.
   * For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power
   * have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100].
   * A chain can join with top_N == 0 as an Opt In chain, or with top_N âˆˆ [50, 100] as a Top N chain.
   */
  topN: number;
  /**
   * Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if
   * `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the
   * consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only
   * 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need
   * to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis.
   */
  validatorsPowerCap: number;
  /**
   * Corresponds to the maximum number of validators that can validate a consumer chain.
   * Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op.
   */
  validatorSetCap: number;
  /**
   * Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate
   * the consumer chain.
   */
  allowlist: string[];
  /** Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain. */
  denylist: string[];
  /** signer address */
  authority: string;
}

export interface MsgConsumerModificationResponse {
}

function createBaseMsgAssignConsumerKey(): MsgAssignConsumerKey {
  return { chainId: "", providerAddr: "", consumerKey: "", signer: "" };
}

export const MsgAssignConsumerKey: MessageFns<MsgAssignConsumerKey> = {
  encode(message: MsgAssignConsumerKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.providerAddr !== "") {
      writer.uint32(18).string(message.providerAddr);
    }
    if (message.consumerKey !== "") {
      writer.uint32(26).string(message.consumerKey);
    }
    if (message.signer !== "") {
      writer.uint32(34).string(message.signer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAssignConsumerKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAssignConsumerKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerAddr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.consumerKey = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAssignConsumerKey {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      providerAddr: isSet(object.providerAddr) ? globalThis.String(object.providerAddr) : "",
      consumerKey: isSet(object.consumerKey) ? globalThis.String(object.consumerKey) : "",
      signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
    };
  },

  toJSON(message: MsgAssignConsumerKey): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.providerAddr !== "") {
      obj.providerAddr = message.providerAddr;
    }
    if (message.consumerKey !== "") {
      obj.consumerKey = message.consumerKey;
    }
    if (message.signer !== "") {
      obj.signer = message.signer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAssignConsumerKey>, I>>(base?: I): MsgAssignConsumerKey {
    return MsgAssignConsumerKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAssignConsumerKey>, I>>(object: I): MsgAssignConsumerKey {
    const message = createBaseMsgAssignConsumerKey();
    message.chainId = object.chainId ?? "";
    message.providerAddr = object.providerAddr ?? "";
    message.consumerKey = object.consumerKey ?? "";
    message.signer = object.signer ?? "";
    return message;
  },
};

function createBaseMsgAssignConsumerKeyResponse(): MsgAssignConsumerKeyResponse {
  return {};
}

export const MsgAssignConsumerKeyResponse: MessageFns<MsgAssignConsumerKeyResponse> = {
  encode(_: MsgAssignConsumerKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAssignConsumerKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAssignConsumerKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAssignConsumerKeyResponse {
    return {};
  },

  toJSON(_: MsgAssignConsumerKeyResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAssignConsumerKeyResponse>, I>>(base?: I): MsgAssignConsumerKeyResponse {
    return MsgAssignConsumerKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAssignConsumerKeyResponse>, I>>(_: I): MsgAssignConsumerKeyResponse {
    const message = createBaseMsgAssignConsumerKeyResponse();
    return message;
  },
};

function createBaseMsgSubmitConsumerMisbehaviour(): MsgSubmitConsumerMisbehaviour {
  return { submitter: "", misbehaviour: undefined };
}

export const MsgSubmitConsumerMisbehaviour: MessageFns<MsgSubmitConsumerMisbehaviour> = {
  encode(message: MsgSubmitConsumerMisbehaviour, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.submitter !== "") {
      writer.uint32(10).string(message.submitter);
    }
    if (message.misbehaviour !== undefined) {
      Misbehaviour.encode(message.misbehaviour, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitConsumerMisbehaviour {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitConsumerMisbehaviour();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.submitter = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.misbehaviour = Misbehaviour.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitConsumerMisbehaviour {
    return {
      submitter: isSet(object.submitter) ? globalThis.String(object.submitter) : "",
      misbehaviour: isSet(object.misbehaviour) ? Misbehaviour.fromJSON(object.misbehaviour) : undefined,
    };
  },

  toJSON(message: MsgSubmitConsumerMisbehaviour): unknown {
    const obj: any = {};
    if (message.submitter !== "") {
      obj.submitter = message.submitter;
    }
    if (message.misbehaviour !== undefined) {
      obj.misbehaviour = Misbehaviour.toJSON(message.misbehaviour);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitConsumerMisbehaviour>, I>>(base?: I): MsgSubmitConsumerMisbehaviour {
    return MsgSubmitConsumerMisbehaviour.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitConsumerMisbehaviour>, I>>(
    object: I,
  ): MsgSubmitConsumerMisbehaviour {
    const message = createBaseMsgSubmitConsumerMisbehaviour();
    message.submitter = object.submitter ?? "";
    message.misbehaviour = (object.misbehaviour !== undefined && object.misbehaviour !== null)
      ? Misbehaviour.fromPartial(object.misbehaviour)
      : undefined;
    return message;
  },
};

function createBaseMsgSubmitConsumerMisbehaviourResponse(): MsgSubmitConsumerMisbehaviourResponse {
  return {};
}

export const MsgSubmitConsumerMisbehaviourResponse: MessageFns<MsgSubmitConsumerMisbehaviourResponse> = {
  encode(_: MsgSubmitConsumerMisbehaviourResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitConsumerMisbehaviourResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitConsumerMisbehaviourResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubmitConsumerMisbehaviourResponse {
    return {};
  },

  toJSON(_: MsgSubmitConsumerMisbehaviourResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitConsumerMisbehaviourResponse>, I>>(
    base?: I,
  ): MsgSubmitConsumerMisbehaviourResponse {
    return MsgSubmitConsumerMisbehaviourResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitConsumerMisbehaviourResponse>, I>>(
    _: I,
  ): MsgSubmitConsumerMisbehaviourResponse {
    const message = createBaseMsgSubmitConsumerMisbehaviourResponse();
    return message;
  },
};

function createBaseMsgSubmitConsumerDoubleVoting(): MsgSubmitConsumerDoubleVoting {
  return { submitter: "", duplicateVoteEvidence: undefined, infractionBlockHeader: undefined };
}

export const MsgSubmitConsumerDoubleVoting: MessageFns<MsgSubmitConsumerDoubleVoting> = {
  encode(message: MsgSubmitConsumerDoubleVoting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.submitter !== "") {
      writer.uint32(10).string(message.submitter);
    }
    if (message.duplicateVoteEvidence !== undefined) {
      DuplicateVoteEvidence.encode(message.duplicateVoteEvidence, writer.uint32(18).fork()).join();
    }
    if (message.infractionBlockHeader !== undefined) {
      Header.encode(message.infractionBlockHeader, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitConsumerDoubleVoting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitConsumerDoubleVoting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.submitter = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.duplicateVoteEvidence = DuplicateVoteEvidence.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.infractionBlockHeader = Header.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitConsumerDoubleVoting {
    return {
      submitter: isSet(object.submitter) ? globalThis.String(object.submitter) : "",
      duplicateVoteEvidence: isSet(object.duplicateVoteEvidence)
        ? DuplicateVoteEvidence.fromJSON(object.duplicateVoteEvidence)
        : undefined,
      infractionBlockHeader: isSet(object.infractionBlockHeader)
        ? Header.fromJSON(object.infractionBlockHeader)
        : undefined,
    };
  },

  toJSON(message: MsgSubmitConsumerDoubleVoting): unknown {
    const obj: any = {};
    if (message.submitter !== "") {
      obj.submitter = message.submitter;
    }
    if (message.duplicateVoteEvidence !== undefined) {
      obj.duplicateVoteEvidence = DuplicateVoteEvidence.toJSON(message.duplicateVoteEvidence);
    }
    if (message.infractionBlockHeader !== undefined) {
      obj.infractionBlockHeader = Header.toJSON(message.infractionBlockHeader);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitConsumerDoubleVoting>, I>>(base?: I): MsgSubmitConsumerDoubleVoting {
    return MsgSubmitConsumerDoubleVoting.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitConsumerDoubleVoting>, I>>(
    object: I,
  ): MsgSubmitConsumerDoubleVoting {
    const message = createBaseMsgSubmitConsumerDoubleVoting();
    message.submitter = object.submitter ?? "";
    message.duplicateVoteEvidence =
      (object.duplicateVoteEvidence !== undefined && object.duplicateVoteEvidence !== null)
        ? DuplicateVoteEvidence.fromPartial(object.duplicateVoteEvidence)
        : undefined;
    message.infractionBlockHeader =
      (object.infractionBlockHeader !== undefined && object.infractionBlockHeader !== null)
        ? Header.fromPartial(object.infractionBlockHeader)
        : undefined;
    return message;
  },
};

function createBaseMsgSubmitConsumerDoubleVotingResponse(): MsgSubmitConsumerDoubleVotingResponse {
  return {};
}

export const MsgSubmitConsumerDoubleVotingResponse: MessageFns<MsgSubmitConsumerDoubleVotingResponse> = {
  encode(_: MsgSubmitConsumerDoubleVotingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitConsumerDoubleVotingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitConsumerDoubleVotingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubmitConsumerDoubleVotingResponse {
    return {};
  },

  toJSON(_: MsgSubmitConsumerDoubleVotingResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitConsumerDoubleVotingResponse>, I>>(
    base?: I,
  ): MsgSubmitConsumerDoubleVotingResponse {
    return MsgSubmitConsumerDoubleVotingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitConsumerDoubleVotingResponse>, I>>(
    _: I,
  ): MsgSubmitConsumerDoubleVotingResponse {
    const message = createBaseMsgSubmitConsumerDoubleVotingResponse();
    return message;
  },
};

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(base?: I): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(object: I): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(base?: I): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(_: I): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgConsumerAddition(): MsgConsumerAddition {
  return {
    chainId: "",
    initialHeight: undefined,
    genesisHash: Buffer.alloc(0),
    binaryHash: Buffer.alloc(0),
    spawnTime: undefined,
    unbondingPeriod: undefined,
    ccvTimeoutPeriod: undefined,
    transferTimeoutPeriod: undefined,
    consumerRedistributionFraction: "",
    blocksPerDistributionTransmission: "0",
    historicalEntries: "0",
    distributionTransmissionChannel: "",
    topN: 0,
    validatorsPowerCap: 0,
    validatorSetCap: 0,
    allowlist: [],
    denylist: [],
    authority: "",
  };
}

export const MsgConsumerAddition: MessageFns<MsgConsumerAddition> = {
  encode(message: MsgConsumerAddition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.initialHeight !== undefined) {
      Height.encode(message.initialHeight, writer.uint32(18).fork()).join();
    }
    if (message.genesisHash.length !== 0) {
      writer.uint32(26).bytes(message.genesisHash);
    }
    if (message.binaryHash.length !== 0) {
      writer.uint32(34).bytes(message.binaryHash);
    }
    if (message.spawnTime !== undefined) {
      Timestamp.encode(toTimestamp(message.spawnTime), writer.uint32(42).fork()).join();
    }
    if (message.unbondingPeriod !== undefined) {
      Duration.encode(message.unbondingPeriod, writer.uint32(50).fork()).join();
    }
    if (message.ccvTimeoutPeriod !== undefined) {
      Duration.encode(message.ccvTimeoutPeriod, writer.uint32(58).fork()).join();
    }
    if (message.transferTimeoutPeriod !== undefined) {
      Duration.encode(message.transferTimeoutPeriod, writer.uint32(66).fork()).join();
    }
    if (message.consumerRedistributionFraction !== "") {
      writer.uint32(74).string(message.consumerRedistributionFraction);
    }
    if (message.blocksPerDistributionTransmission !== "0") {
      writer.uint32(80).int64(message.blocksPerDistributionTransmission);
    }
    if (message.historicalEntries !== "0") {
      writer.uint32(88).int64(message.historicalEntries);
    }
    if (message.distributionTransmissionChannel !== "") {
      writer.uint32(98).string(message.distributionTransmissionChannel);
    }
    if (message.topN !== 0) {
      writer.uint32(104).uint32(message.topN);
    }
    if (message.validatorsPowerCap !== 0) {
      writer.uint32(112).uint32(message.validatorsPowerCap);
    }
    if (message.validatorSetCap !== 0) {
      writer.uint32(120).uint32(message.validatorSetCap);
    }
    for (const v of message.allowlist) {
      writer.uint32(130).string(v!);
    }
    for (const v of message.denylist) {
      writer.uint32(138).string(v!);
    }
    if (message.authority !== "") {
      writer.uint32(146).string(message.authority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgConsumerAddition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgConsumerAddition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.initialHeight = Height.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.genesisHash = Buffer.from(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.binaryHash = Buffer.from(reader.bytes());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.spawnTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.unbondingPeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.ccvTimeoutPeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.transferTimeoutPeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.consumerRedistributionFraction = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.blocksPerDistributionTransmission = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.historicalEntries = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.distributionTransmissionChannel = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.topN = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.validatorsPowerCap = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.validatorSetCap = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.allowlist.push(reader.string());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.denylist.push(reader.string());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgConsumerAddition {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      initialHeight: isSet(object.initialHeight) ? Height.fromJSON(object.initialHeight) : undefined,
      genesisHash: isSet(object.genesisHash) ? Buffer.from(bytesFromBase64(object.genesisHash)) : Buffer.alloc(0),
      binaryHash: isSet(object.binaryHash) ? Buffer.from(bytesFromBase64(object.binaryHash)) : Buffer.alloc(0),
      spawnTime: isSet(object.spawnTime) ? fromJsonTimestamp(object.spawnTime) : undefined,
      unbondingPeriod: isSet(object.unbondingPeriod) ? Duration.fromJSON(object.unbondingPeriod) : undefined,
      ccvTimeoutPeriod: isSet(object.ccvTimeoutPeriod) ? Duration.fromJSON(object.ccvTimeoutPeriod) : undefined,
      transferTimeoutPeriod: isSet(object.transferTimeoutPeriod)
        ? Duration.fromJSON(object.transferTimeoutPeriod)
        : undefined,
      consumerRedistributionFraction: isSet(object.consumerRedistributionFraction)
        ? globalThis.String(object.consumerRedistributionFraction)
        : "",
      blocksPerDistributionTransmission: isSet(object.blocksPerDistributionTransmission)
        ? globalThis.String(object.blocksPerDistributionTransmission)
        : "0",
      historicalEntries: isSet(object.historicalEntries) ? globalThis.String(object.historicalEntries) : "0",
      distributionTransmissionChannel: isSet(object.distributionTransmissionChannel)
        ? globalThis.String(object.distributionTransmissionChannel)
        : "",
      topN: isSet(object.topN) ? globalThis.Number(object.topN) : 0,
      validatorsPowerCap: isSet(object.validatorsPowerCap) ? globalThis.Number(object.validatorsPowerCap) : 0,
      validatorSetCap: isSet(object.validatorSetCap) ? globalThis.Number(object.validatorSetCap) : 0,
      allowlist: globalThis.Array.isArray(object?.allowlist)
        ? object.allowlist.map((e: any) => globalThis.String(e))
        : [],
      denylist: globalThis.Array.isArray(object?.denylist) ? object.denylist.map((e: any) => globalThis.String(e)) : [],
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
    };
  },

  toJSON(message: MsgConsumerAddition): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.initialHeight !== undefined) {
      obj.initialHeight = Height.toJSON(message.initialHeight);
    }
    if (message.genesisHash.length !== 0) {
      obj.genesisHash = base64FromBytes(message.genesisHash);
    }
    if (message.binaryHash.length !== 0) {
      obj.binaryHash = base64FromBytes(message.binaryHash);
    }
    if (message.spawnTime !== undefined) {
      obj.spawnTime = message.spawnTime.toISOString();
    }
    if (message.unbondingPeriod !== undefined) {
      obj.unbondingPeriod = Duration.toJSON(message.unbondingPeriod);
    }
    if (message.ccvTimeoutPeriod !== undefined) {
      obj.ccvTimeoutPeriod = Duration.toJSON(message.ccvTimeoutPeriod);
    }
    if (message.transferTimeoutPeriod !== undefined) {
      obj.transferTimeoutPeriod = Duration.toJSON(message.transferTimeoutPeriod);
    }
    if (message.consumerRedistributionFraction !== "") {
      obj.consumerRedistributionFraction = message.consumerRedistributionFraction;
    }
    if (message.blocksPerDistributionTransmission !== "0") {
      obj.blocksPerDistributionTransmission = message.blocksPerDistributionTransmission;
    }
    if (message.historicalEntries !== "0") {
      obj.historicalEntries = message.historicalEntries;
    }
    if (message.distributionTransmissionChannel !== "") {
      obj.distributionTransmissionChannel = message.distributionTransmissionChannel;
    }
    if (message.topN !== 0) {
      obj.topN = Math.round(message.topN);
    }
    if (message.validatorsPowerCap !== 0) {
      obj.validatorsPowerCap = Math.round(message.validatorsPowerCap);
    }
    if (message.validatorSetCap !== 0) {
      obj.validatorSetCap = Math.round(message.validatorSetCap);
    }
    if (message.allowlist?.length) {
      obj.allowlist = message.allowlist;
    }
    if (message.denylist?.length) {
      obj.denylist = message.denylist;
    }
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgConsumerAddition>, I>>(base?: I): MsgConsumerAddition {
    return MsgConsumerAddition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgConsumerAddition>, I>>(object: I): MsgConsumerAddition {
    const message = createBaseMsgConsumerAddition();
    message.chainId = object.chainId ?? "";
    message.initialHeight = (object.initialHeight !== undefined && object.initialHeight !== null)
      ? Height.fromPartial(object.initialHeight)
      : undefined;
    message.genesisHash = object.genesisHash ?? Buffer.alloc(0);
    message.binaryHash = object.binaryHash ?? Buffer.alloc(0);
    message.spawnTime = object.spawnTime ?? undefined;
    message.unbondingPeriod = (object.unbondingPeriod !== undefined && object.unbondingPeriod !== null)
      ? Duration.fromPartial(object.unbondingPeriod)
      : undefined;
    message.ccvTimeoutPeriod = (object.ccvTimeoutPeriod !== undefined && object.ccvTimeoutPeriod !== null)
      ? Duration.fromPartial(object.ccvTimeoutPeriod)
      : undefined;
    message.transferTimeoutPeriod =
      (object.transferTimeoutPeriod !== undefined && object.transferTimeoutPeriod !== null)
        ? Duration.fromPartial(object.transferTimeoutPeriod)
        : undefined;
    message.consumerRedistributionFraction = object.consumerRedistributionFraction ?? "";
    message.blocksPerDistributionTransmission = object.blocksPerDistributionTransmission ?? "0";
    message.historicalEntries = object.historicalEntries ?? "0";
    message.distributionTransmissionChannel = object.distributionTransmissionChannel ?? "";
    message.topN = object.topN ?? 0;
    message.validatorsPowerCap = object.validatorsPowerCap ?? 0;
    message.validatorSetCap = object.validatorSetCap ?? 0;
    message.allowlist = object.allowlist?.map((e) => e) || [];
    message.denylist = object.denylist?.map((e) => e) || [];
    message.authority = object.authority ?? "";
    return message;
  },
};

function createBaseMsgConsumerAdditionResponse(): MsgConsumerAdditionResponse {
  return {};
}

export const MsgConsumerAdditionResponse: MessageFns<MsgConsumerAdditionResponse> = {
  encode(_: MsgConsumerAdditionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgConsumerAdditionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgConsumerAdditionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgConsumerAdditionResponse {
    return {};
  },

  toJSON(_: MsgConsumerAdditionResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgConsumerAdditionResponse>, I>>(base?: I): MsgConsumerAdditionResponse {
    return MsgConsumerAdditionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgConsumerAdditionResponse>, I>>(_: I): MsgConsumerAdditionResponse {
    const message = createBaseMsgConsumerAdditionResponse();
    return message;
  },
};

function createBaseMsgConsumerRemoval(): MsgConsumerRemoval {
  return { chainId: "", stopTime: undefined, authority: "" };
}

export const MsgConsumerRemoval: MessageFns<MsgConsumerRemoval> = {
  encode(message: MsgConsumerRemoval, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.stopTime !== undefined) {
      Timestamp.encode(toTimestamp(message.stopTime), writer.uint32(18).fork()).join();
    }
    if (message.authority !== "") {
      writer.uint32(26).string(message.authority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgConsumerRemoval {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgConsumerRemoval();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stopTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgConsumerRemoval {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      stopTime: isSet(object.stopTime) ? fromJsonTimestamp(object.stopTime) : undefined,
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
    };
  },

  toJSON(message: MsgConsumerRemoval): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.stopTime !== undefined) {
      obj.stopTime = message.stopTime.toISOString();
    }
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgConsumerRemoval>, I>>(base?: I): MsgConsumerRemoval {
    return MsgConsumerRemoval.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgConsumerRemoval>, I>>(object: I): MsgConsumerRemoval {
    const message = createBaseMsgConsumerRemoval();
    message.chainId = object.chainId ?? "";
    message.stopTime = object.stopTime ?? undefined;
    message.authority = object.authority ?? "";
    return message;
  },
};

function createBaseMsgConsumerRemovalResponse(): MsgConsumerRemovalResponse {
  return {};
}

export const MsgConsumerRemovalResponse: MessageFns<MsgConsumerRemovalResponse> = {
  encode(_: MsgConsumerRemovalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgConsumerRemovalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgConsumerRemovalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgConsumerRemovalResponse {
    return {};
  },

  toJSON(_: MsgConsumerRemovalResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgConsumerRemovalResponse>, I>>(base?: I): MsgConsumerRemovalResponse {
    return MsgConsumerRemovalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgConsumerRemovalResponse>, I>>(_: I): MsgConsumerRemovalResponse {
    const message = createBaseMsgConsumerRemovalResponse();
    return message;
  },
};

function createBaseMsgChangeRewardDenoms(): MsgChangeRewardDenoms {
  return { denomsToAdd: [], denomsToRemove: [], authority: "" };
}

export const MsgChangeRewardDenoms: MessageFns<MsgChangeRewardDenoms> = {
  encode(message: MsgChangeRewardDenoms, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.denomsToAdd) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.denomsToRemove) {
      writer.uint32(18).string(v!);
    }
    if (message.authority !== "") {
      writer.uint32(26).string(message.authority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgChangeRewardDenoms {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgChangeRewardDenoms();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denomsToAdd.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.denomsToRemove.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgChangeRewardDenoms {
    return {
      denomsToAdd: globalThis.Array.isArray(object?.denomsToAdd)
        ? object.denomsToAdd.map((e: any) => globalThis.String(e))
        : [],
      denomsToRemove: globalThis.Array.isArray(object?.denomsToRemove)
        ? object.denomsToRemove.map((e: any) => globalThis.String(e))
        : [],
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
    };
  },

  toJSON(message: MsgChangeRewardDenoms): unknown {
    const obj: any = {};
    if (message.denomsToAdd?.length) {
      obj.denomsToAdd = message.denomsToAdd;
    }
    if (message.denomsToRemove?.length) {
      obj.denomsToRemove = message.denomsToRemove;
    }
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgChangeRewardDenoms>, I>>(base?: I): MsgChangeRewardDenoms {
    return MsgChangeRewardDenoms.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgChangeRewardDenoms>, I>>(object: I): MsgChangeRewardDenoms {
    const message = createBaseMsgChangeRewardDenoms();
    message.denomsToAdd = object.denomsToAdd?.map((e) => e) || [];
    message.denomsToRemove = object.denomsToRemove?.map((e) => e) || [];
    message.authority = object.authority ?? "";
    return message;
  },
};

function createBaseMsgChangeRewardDenomsResponse(): MsgChangeRewardDenomsResponse {
  return {};
}

export const MsgChangeRewardDenomsResponse: MessageFns<MsgChangeRewardDenomsResponse> = {
  encode(_: MsgChangeRewardDenomsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgChangeRewardDenomsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgChangeRewardDenomsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgChangeRewardDenomsResponse {
    return {};
  },

  toJSON(_: MsgChangeRewardDenomsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgChangeRewardDenomsResponse>, I>>(base?: I): MsgChangeRewardDenomsResponse {
    return MsgChangeRewardDenomsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgChangeRewardDenomsResponse>, I>>(_: I): MsgChangeRewardDenomsResponse {
    const message = createBaseMsgChangeRewardDenomsResponse();
    return message;
  },
};

function createBaseMsgOptIn(): MsgOptIn {
  return { chainId: "", providerAddr: "", consumerKey: "", signer: "" };
}

export const MsgOptIn: MessageFns<MsgOptIn> = {
  encode(message: MsgOptIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.providerAddr !== "") {
      writer.uint32(18).string(message.providerAddr);
    }
    if (message.consumerKey !== "") {
      writer.uint32(26).string(message.consumerKey);
    }
    if (message.signer !== "") {
      writer.uint32(34).string(message.signer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgOptIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgOptIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerAddr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.consumerKey = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgOptIn {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      providerAddr: isSet(object.providerAddr) ? globalThis.String(object.providerAddr) : "",
      consumerKey: isSet(object.consumerKey) ? globalThis.String(object.consumerKey) : "",
      signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
    };
  },

  toJSON(message: MsgOptIn): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.providerAddr !== "") {
      obj.providerAddr = message.providerAddr;
    }
    if (message.consumerKey !== "") {
      obj.consumerKey = message.consumerKey;
    }
    if (message.signer !== "") {
      obj.signer = message.signer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgOptIn>, I>>(base?: I): MsgOptIn {
    return MsgOptIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgOptIn>, I>>(object: I): MsgOptIn {
    const message = createBaseMsgOptIn();
    message.chainId = object.chainId ?? "";
    message.providerAddr = object.providerAddr ?? "";
    message.consumerKey = object.consumerKey ?? "";
    message.signer = object.signer ?? "";
    return message;
  },
};

function createBaseMsgOptInResponse(): MsgOptInResponse {
  return {};
}

export const MsgOptInResponse: MessageFns<MsgOptInResponse> = {
  encode(_: MsgOptInResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgOptInResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgOptInResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgOptInResponse {
    return {};
  },

  toJSON(_: MsgOptInResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgOptInResponse>, I>>(base?: I): MsgOptInResponse {
    return MsgOptInResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgOptInResponse>, I>>(_: I): MsgOptInResponse {
    const message = createBaseMsgOptInResponse();
    return message;
  },
};

function createBaseMsgOptOut(): MsgOptOut {
  return { chainId: "", providerAddr: "", signer: "" };
}

export const MsgOptOut: MessageFns<MsgOptOut> = {
  encode(message: MsgOptOut, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.providerAddr !== "") {
      writer.uint32(18).string(message.providerAddr);
    }
    if (message.signer !== "") {
      writer.uint32(26).string(message.signer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgOptOut {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgOptOut();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerAddr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgOptOut {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      providerAddr: isSet(object.providerAddr) ? globalThis.String(object.providerAddr) : "",
      signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
    };
  },

  toJSON(message: MsgOptOut): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.providerAddr !== "") {
      obj.providerAddr = message.providerAddr;
    }
    if (message.signer !== "") {
      obj.signer = message.signer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgOptOut>, I>>(base?: I): MsgOptOut {
    return MsgOptOut.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgOptOut>, I>>(object: I): MsgOptOut {
    const message = createBaseMsgOptOut();
    message.chainId = object.chainId ?? "";
    message.providerAddr = object.providerAddr ?? "";
    message.signer = object.signer ?? "";
    return message;
  },
};

function createBaseMsgOptOutResponse(): MsgOptOutResponse {
  return {};
}

export const MsgOptOutResponse: MessageFns<MsgOptOutResponse> = {
  encode(_: MsgOptOutResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgOptOutResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgOptOutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgOptOutResponse {
    return {};
  },

  toJSON(_: MsgOptOutResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgOptOutResponse>, I>>(base?: I): MsgOptOutResponse {
    return MsgOptOutResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgOptOutResponse>, I>>(_: I): MsgOptOutResponse {
    const message = createBaseMsgOptOutResponse();
    return message;
  },
};

function createBaseMsgSetConsumerCommissionRate(): MsgSetConsumerCommissionRate {
  return { providerAddr: "", chainId: "", rate: "", signer: "" };
}

export const MsgSetConsumerCommissionRate: MessageFns<MsgSetConsumerCommissionRate> = {
  encode(message: MsgSetConsumerCommissionRate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerAddr !== "") {
      writer.uint32(10).string(message.providerAddr);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.rate !== "") {
      writer.uint32(26).string(message.rate);
    }
    if (message.signer !== "") {
      writer.uint32(34).string(message.signer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetConsumerCommissionRate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetConsumerCommissionRate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerAddr = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetConsumerCommissionRate {
    return {
      providerAddr: isSet(object.providerAddr) ? globalThis.String(object.providerAddr) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      rate: isSet(object.rate) ? globalThis.String(object.rate) : "",
      signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
    };
  },

  toJSON(message: MsgSetConsumerCommissionRate): unknown {
    const obj: any = {};
    if (message.providerAddr !== "") {
      obj.providerAddr = message.providerAddr;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.rate !== "") {
      obj.rate = message.rate;
    }
    if (message.signer !== "") {
      obj.signer = message.signer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetConsumerCommissionRate>, I>>(base?: I): MsgSetConsumerCommissionRate {
    return MsgSetConsumerCommissionRate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetConsumerCommissionRate>, I>>(object: I): MsgSetConsumerCommissionRate {
    const message = createBaseMsgSetConsumerCommissionRate();
    message.providerAddr = object.providerAddr ?? "";
    message.chainId = object.chainId ?? "";
    message.rate = object.rate ?? "";
    message.signer = object.signer ?? "";
    return message;
  },
};

function createBaseMsgSetConsumerCommissionRateResponse(): MsgSetConsumerCommissionRateResponse {
  return {};
}

export const MsgSetConsumerCommissionRateResponse: MessageFns<MsgSetConsumerCommissionRateResponse> = {
  encode(_: MsgSetConsumerCommissionRateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetConsumerCommissionRateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetConsumerCommissionRateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetConsumerCommissionRateResponse {
    return {};
  },

  toJSON(_: MsgSetConsumerCommissionRateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetConsumerCommissionRateResponse>, I>>(
    base?: I,
  ): MsgSetConsumerCommissionRateResponse {
    return MsgSetConsumerCommissionRateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetConsumerCommissionRateResponse>, I>>(
    _: I,
  ): MsgSetConsumerCommissionRateResponse {
    const message = createBaseMsgSetConsumerCommissionRateResponse();
    return message;
  },
};

function createBaseMsgConsumerModification(): MsgConsumerModification {
  return {
    title: "",
    description: "",
    chainId: "",
    topN: 0,
    validatorsPowerCap: 0,
    validatorSetCap: 0,
    allowlist: [],
    denylist: [],
    authority: "",
  };
}

export const MsgConsumerModification: MessageFns<MsgConsumerModification> = {
  encode(message: MsgConsumerModification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.topN !== 0) {
      writer.uint32(32).uint32(message.topN);
    }
    if (message.validatorsPowerCap !== 0) {
      writer.uint32(40).uint32(message.validatorsPowerCap);
    }
    if (message.validatorSetCap !== 0) {
      writer.uint32(48).uint32(message.validatorSetCap);
    }
    for (const v of message.allowlist) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.denylist) {
      writer.uint32(66).string(v!);
    }
    if (message.authority !== "") {
      writer.uint32(74).string(message.authority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgConsumerModification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgConsumerModification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.topN = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.validatorsPowerCap = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.validatorSetCap = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.allowlist.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.denylist.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgConsumerModification {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      topN: isSet(object.topN) ? globalThis.Number(object.topN) : 0,
      validatorsPowerCap: isSet(object.validatorsPowerCap) ? globalThis.Number(object.validatorsPowerCap) : 0,
      validatorSetCap: isSet(object.validatorSetCap) ? globalThis.Number(object.validatorSetCap) : 0,
      allowlist: globalThis.Array.isArray(object?.allowlist)
        ? object.allowlist.map((e: any) => globalThis.String(e))
        : [],
      denylist: globalThis.Array.isArray(object?.denylist) ? object.denylist.map((e: any) => globalThis.String(e)) : [],
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
    };
  },

  toJSON(message: MsgConsumerModification): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.topN !== 0) {
      obj.topN = Math.round(message.topN);
    }
    if (message.validatorsPowerCap !== 0) {
      obj.validatorsPowerCap = Math.round(message.validatorsPowerCap);
    }
    if (message.validatorSetCap !== 0) {
      obj.validatorSetCap = Math.round(message.validatorSetCap);
    }
    if (message.allowlist?.length) {
      obj.allowlist = message.allowlist;
    }
    if (message.denylist?.length) {
      obj.denylist = message.denylist;
    }
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgConsumerModification>, I>>(base?: I): MsgConsumerModification {
    return MsgConsumerModification.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgConsumerModification>, I>>(object: I): MsgConsumerModification {
    const message = createBaseMsgConsumerModification();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.chainId = object.chainId ?? "";
    message.topN = object.topN ?? 0;
    message.validatorsPowerCap = object.validatorsPowerCap ?? 0;
    message.validatorSetCap = object.validatorSetCap ?? 0;
    message.allowlist = object.allowlist?.map((e) => e) || [];
    message.denylist = object.denylist?.map((e) => e) || [];
    message.authority = object.authority ?? "";
    return message;
  },
};

function createBaseMsgConsumerModificationResponse(): MsgConsumerModificationResponse {
  return {};
}

export const MsgConsumerModificationResponse: MessageFns<MsgConsumerModificationResponse> = {
  encode(_: MsgConsumerModificationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgConsumerModificationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgConsumerModificationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgConsumerModificationResponse {
    return {};
  },

  toJSON(_: MsgConsumerModificationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgConsumerModificationResponse>, I>>(base?: I): MsgConsumerModificationResponse {
    return MsgConsumerModificationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgConsumerModificationResponse>, I>>(_: I): MsgConsumerModificationResponse {
    const message = createBaseMsgConsumerModificationResponse();
    return message;
  },
};

/** Msg defines the Msg service. */
export type MsgService = typeof MsgService;
export const MsgService = {
  assignConsumerKey: {
    path: "/interchain_security.ccv.provider.v1.Msg/AssignConsumerKey",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgAssignConsumerKey) => Buffer.from(MsgAssignConsumerKey.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgAssignConsumerKey.decode(value),
    responseSerialize: (value: MsgAssignConsumerKeyResponse) =>
      Buffer.from(MsgAssignConsumerKeyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgAssignConsumerKeyResponse.decode(value),
  },
  submitConsumerMisbehaviour: {
    path: "/interchain_security.ccv.provider.v1.Msg/SubmitConsumerMisbehaviour",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgSubmitConsumerMisbehaviour) =>
      Buffer.from(MsgSubmitConsumerMisbehaviour.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgSubmitConsumerMisbehaviour.decode(value),
    responseSerialize: (value: MsgSubmitConsumerMisbehaviourResponse) =>
      Buffer.from(MsgSubmitConsumerMisbehaviourResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgSubmitConsumerMisbehaviourResponse.decode(value),
  },
  submitConsumerDoubleVoting: {
    path: "/interchain_security.ccv.provider.v1.Msg/SubmitConsumerDoubleVoting",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgSubmitConsumerDoubleVoting) =>
      Buffer.from(MsgSubmitConsumerDoubleVoting.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgSubmitConsumerDoubleVoting.decode(value),
    responseSerialize: (value: MsgSubmitConsumerDoubleVotingResponse) =>
      Buffer.from(MsgSubmitConsumerDoubleVotingResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgSubmitConsumerDoubleVotingResponse.decode(value),
  },
  consumerAddition: {
    path: "/interchain_security.ccv.provider.v1.Msg/ConsumerAddition",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgConsumerAddition) => Buffer.from(MsgConsumerAddition.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgConsumerAddition.decode(value),
    responseSerialize: (value: MsgConsumerAdditionResponse) =>
      Buffer.from(MsgConsumerAdditionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgConsumerAdditionResponse.decode(value),
  },
  consumerRemoval: {
    path: "/interchain_security.ccv.provider.v1.Msg/ConsumerRemoval",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgConsumerRemoval) => Buffer.from(MsgConsumerRemoval.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgConsumerRemoval.decode(value),
    responseSerialize: (value: MsgConsumerRemovalResponse) =>
      Buffer.from(MsgConsumerRemovalResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgConsumerRemovalResponse.decode(value),
  },
  updateParams: {
    path: "/interchain_security.ccv.provider.v1.Msg/UpdateParams",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgUpdateParams) => Buffer.from(MsgUpdateParams.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgUpdateParams.decode(value),
    responseSerialize: (value: MsgUpdateParamsResponse) => Buffer.from(MsgUpdateParamsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgUpdateParamsResponse.decode(value),
  },
  optIn: {
    path: "/interchain_security.ccv.provider.v1.Msg/OptIn",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgOptIn) => Buffer.from(MsgOptIn.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgOptIn.decode(value),
    responseSerialize: (value: MsgOptInResponse) => Buffer.from(MsgOptInResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgOptInResponse.decode(value),
  },
  optOut: {
    path: "/interchain_security.ccv.provider.v1.Msg/OptOut",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgOptOut) => Buffer.from(MsgOptOut.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgOptOut.decode(value),
    responseSerialize: (value: MsgOptOutResponse) => Buffer.from(MsgOptOutResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgOptOutResponse.decode(value),
  },
  setConsumerCommissionRate: {
    path: "/interchain_security.ccv.provider.v1.Msg/SetConsumerCommissionRate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgSetConsumerCommissionRate) =>
      Buffer.from(MsgSetConsumerCommissionRate.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgSetConsumerCommissionRate.decode(value),
    responseSerialize: (value: MsgSetConsumerCommissionRateResponse) =>
      Buffer.from(MsgSetConsumerCommissionRateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgSetConsumerCommissionRateResponse.decode(value),
  },
  consumerModification: {
    path: "/interchain_security.ccv.provider.v1.Msg/ConsumerModification",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgConsumerModification) => Buffer.from(MsgConsumerModification.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgConsumerModification.decode(value),
    responseSerialize: (value: MsgConsumerModificationResponse) =>
      Buffer.from(MsgConsumerModificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgConsumerModificationResponse.decode(value),
  },
} as const;

export interface MsgServer extends UntypedServiceImplementation {
  assignConsumerKey: handleUnaryCall<MsgAssignConsumerKey, MsgAssignConsumerKeyResponse>;
  submitConsumerMisbehaviour: handleUnaryCall<MsgSubmitConsumerMisbehaviour, MsgSubmitConsumerMisbehaviourResponse>;
  submitConsumerDoubleVoting: handleUnaryCall<MsgSubmitConsumerDoubleVoting, MsgSubmitConsumerDoubleVotingResponse>;
  consumerAddition: handleUnaryCall<MsgConsumerAddition, MsgConsumerAdditionResponse>;
  consumerRemoval: handleUnaryCall<MsgConsumerRemoval, MsgConsumerRemovalResponse>;
  updateParams: handleUnaryCall<MsgUpdateParams, MsgUpdateParamsResponse>;
  optIn: handleUnaryCall<MsgOptIn, MsgOptInResponse>;
  optOut: handleUnaryCall<MsgOptOut, MsgOptOutResponse>;
  setConsumerCommissionRate: handleUnaryCall<MsgSetConsumerCommissionRate, MsgSetConsumerCommissionRateResponse>;
  consumerModification: handleUnaryCall<MsgConsumerModification, MsgConsumerModificationResponse>;
}

export interface MsgClient extends Client {
  assignConsumerKey(
    request: MsgAssignConsumerKey,
    callback: (error: ServiceError | null, response: MsgAssignConsumerKeyResponse) => void,
  ): ClientUnaryCall;
  assignConsumerKey(
    request: MsgAssignConsumerKey,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgAssignConsumerKeyResponse) => void,
  ): ClientUnaryCall;
  assignConsumerKey(
    request: MsgAssignConsumerKey,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgAssignConsumerKeyResponse) => void,
  ): ClientUnaryCall;
  submitConsumerMisbehaviour(
    request: MsgSubmitConsumerMisbehaviour,
    callback: (error: ServiceError | null, response: MsgSubmitConsumerMisbehaviourResponse) => void,
  ): ClientUnaryCall;
  submitConsumerMisbehaviour(
    request: MsgSubmitConsumerMisbehaviour,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgSubmitConsumerMisbehaviourResponse) => void,
  ): ClientUnaryCall;
  submitConsumerMisbehaviour(
    request: MsgSubmitConsumerMisbehaviour,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgSubmitConsumerMisbehaviourResponse) => void,
  ): ClientUnaryCall;
  submitConsumerDoubleVoting(
    request: MsgSubmitConsumerDoubleVoting,
    callback: (error: ServiceError | null, response: MsgSubmitConsumerDoubleVotingResponse) => void,
  ): ClientUnaryCall;
  submitConsumerDoubleVoting(
    request: MsgSubmitConsumerDoubleVoting,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgSubmitConsumerDoubleVotingResponse) => void,
  ): ClientUnaryCall;
  submitConsumerDoubleVoting(
    request: MsgSubmitConsumerDoubleVoting,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgSubmitConsumerDoubleVotingResponse) => void,
  ): ClientUnaryCall;
  consumerAddition(
    request: MsgConsumerAddition,
    callback: (error: ServiceError | null, response: MsgConsumerAdditionResponse) => void,
  ): ClientUnaryCall;
  consumerAddition(
    request: MsgConsumerAddition,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgConsumerAdditionResponse) => void,
  ): ClientUnaryCall;
  consumerAddition(
    request: MsgConsumerAddition,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgConsumerAdditionResponse) => void,
  ): ClientUnaryCall;
  consumerRemoval(
    request: MsgConsumerRemoval,
    callback: (error: ServiceError | null, response: MsgConsumerRemovalResponse) => void,
  ): ClientUnaryCall;
  consumerRemoval(
    request: MsgConsumerRemoval,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgConsumerRemovalResponse) => void,
  ): ClientUnaryCall;
  consumerRemoval(
    request: MsgConsumerRemoval,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgConsumerRemovalResponse) => void,
  ): ClientUnaryCall;
  updateParams(
    request: MsgUpdateParams,
    callback: (error: ServiceError | null, response: MsgUpdateParamsResponse) => void,
  ): ClientUnaryCall;
  updateParams(
    request: MsgUpdateParams,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgUpdateParamsResponse) => void,
  ): ClientUnaryCall;
  updateParams(
    request: MsgUpdateParams,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgUpdateParamsResponse) => void,
  ): ClientUnaryCall;
  optIn(request: MsgOptIn, callback: (error: ServiceError | null, response: MsgOptInResponse) => void): ClientUnaryCall;
  optIn(
    request: MsgOptIn,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgOptInResponse) => void,
  ): ClientUnaryCall;
  optIn(
    request: MsgOptIn,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgOptInResponse) => void,
  ): ClientUnaryCall;
  optOut(
    request: MsgOptOut,
    callback: (error: ServiceError | null, response: MsgOptOutResponse) => void,
  ): ClientUnaryCall;
  optOut(
    request: MsgOptOut,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgOptOutResponse) => void,
  ): ClientUnaryCall;
  optOut(
    request: MsgOptOut,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgOptOutResponse) => void,
  ): ClientUnaryCall;
  setConsumerCommissionRate(
    request: MsgSetConsumerCommissionRate,
    callback: (error: ServiceError | null, response: MsgSetConsumerCommissionRateResponse) => void,
  ): ClientUnaryCall;
  setConsumerCommissionRate(
    request: MsgSetConsumerCommissionRate,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgSetConsumerCommissionRateResponse) => void,
  ): ClientUnaryCall;
  setConsumerCommissionRate(
    request: MsgSetConsumerCommissionRate,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgSetConsumerCommissionRateResponse) => void,
  ): ClientUnaryCall;
  consumerModification(
    request: MsgConsumerModification,
    callback: (error: ServiceError | null, response: MsgConsumerModificationResponse) => void,
  ): ClientUnaryCall;
  consumerModification(
    request: MsgConsumerModification,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgConsumerModificationResponse) => void,
  ): ClientUnaryCall;
  consumerModification(
    request: MsgConsumerModification,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgConsumerModificationResponse) => void,
  ): ClientUnaryCall;
}

export const MsgClient = makeGenericClientConstructor(
  MsgService,
  "interchain_security.ccv.provider.v1.Msg",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): MsgClient;
  service: typeof MsgService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
