// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: interchain_security/ccv/v1/shared_consumer.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../google/protobuf/duration.js";
import { ClientState, ConsensusState } from "../../../ibc/lightclients/tendermint/v1/tendermint.js";
import { ValidatorUpdate } from "../../../tendermint/abci/types.js";

export const protobufPackage = "interchain_security.ccv.v1";

/**
 * ConsumerParams defines the parameters for CCV consumer module.
 *
 * Note this type is referenced in both the consumer and provider CCV modules,
 * and persisted on the provider, see MakeConsumerGenesis and
 * SetConsumerGenesis.
 */
export interface ConsumerParams {
  /**
   * TODO: Remove enabled flag and find a better way to setup integration tests
   * See: https://github.com/cosmos/interchain-security/issues/339
   */
  enabled: boolean;
  /**
   * /////////////////////
   * Distribution Params
   * Number of blocks between ibc-token-transfers from the consumer chain to
   * the provider chain. Note that at this transmission event a fraction of
   * the accumulated tokens are divided and sent consumer redistribution
   * address.
   */
  blocksPerDistributionTransmission: string;
  /**
   * Channel, and provider-chain receiving address to send distribution token
   * transfers over. These parameters is auto-set during the consumer <->
   * provider handshake procedure.
   */
  distributionTransmissionChannel: string;
  providerFeePoolAddrStr: string;
  /** Sent CCV related IBC packets will timeout after this duration */
  ccvTimeoutPeriod?:
    | Duration
    | undefined;
  /** Sent transfer related IBC packets will timeout after this duration */
  transferTimeoutPeriod?:
    | Duration
    | undefined;
  /**
   * The fraction of tokens allocated to the consumer redistribution address
   * during distribution events. The fraction is a string representing a
   * decimal number. For example "0.75" would represent 75%.
   */
  consumerRedistributionFraction: string;
  /**
   * The number of historical info entries to persist in store.
   * This param is a part of the cosmos sdk staking module. In the case of
   * a ccv enabled consumer chain, the ccv module acts as the staking module.
   */
  historicalEntries: string;
  /**
   * Unbonding period for the consumer,
   * which should be smaller than that of the provider in general.
   */
  unbondingPeriod?:
    | Duration
    | undefined;
  /**
   * !!! DEPRECATED !!! soft_opt_out_threshold is deprecated. see docs/docs/adrs/adr-015-partial-set-security.md
   *
   * @deprecated
   */
  softOptOutThreshold: string;
  /**
   * Reward denoms. These are the denominations which are allowed to be sent to
   * the provider as rewards.
   */
  rewardDenoms: string[];
  /**
   * Provider-originated reward denoms. These are denoms coming from the
   * provider which are allowed to be used as rewards. e.g. "uatom"
   */
  providerRewardDenoms: string[];
  /** The period after which a consumer can retry sending a throttled packet. */
  retryDelayPeriod?: Duration | undefined;
}

/**
 * ConsumerGenesisState defines shared genesis information between provider and
 * consumer
 */
export interface ConsumerGenesisState {
  params?: ConsumerParams | undefined;
  provider?:
    | ProviderInfo
    | undefined;
  /** true for new chain, false for chain restart. */
  newChain: boolean;
}

/**
 * ProviderInfo defines all information a consumer needs from a provider
 * Shared data type between provider and consumer
 */
export interface ProviderInfo {
  /** ProviderClientState filled in on new chain, nil on restart. */
  clientState?:
    | ClientState
    | undefined;
  /** ProviderConsensusState filled in on new chain, nil on restart. */
  consensusState?:
    | ConsensusState
    | undefined;
  /** InitialValset filled in on new chain and on restart. */
  initialValSet: ValidatorUpdate[];
}

function createBaseConsumerParams(): ConsumerParams {
  return {
    enabled: false,
    blocksPerDistributionTransmission: "0",
    distributionTransmissionChannel: "",
    providerFeePoolAddrStr: "",
    ccvTimeoutPeriod: undefined,
    transferTimeoutPeriod: undefined,
    consumerRedistributionFraction: "",
    historicalEntries: "0",
    unbondingPeriod: undefined,
    softOptOutThreshold: "",
    rewardDenoms: [],
    providerRewardDenoms: [],
    retryDelayPeriod: undefined,
  };
}

export const ConsumerParams: MessageFns<ConsumerParams> = {
  encode(message: ConsumerParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.blocksPerDistributionTransmission !== "0") {
      writer.uint32(16).int64(message.blocksPerDistributionTransmission);
    }
    if (message.distributionTransmissionChannel !== "") {
      writer.uint32(26).string(message.distributionTransmissionChannel);
    }
    if (message.providerFeePoolAddrStr !== "") {
      writer.uint32(34).string(message.providerFeePoolAddrStr);
    }
    if (message.ccvTimeoutPeriod !== undefined) {
      Duration.encode(message.ccvTimeoutPeriod, writer.uint32(42).fork()).join();
    }
    if (message.transferTimeoutPeriod !== undefined) {
      Duration.encode(message.transferTimeoutPeriod, writer.uint32(50).fork()).join();
    }
    if (message.consumerRedistributionFraction !== "") {
      writer.uint32(58).string(message.consumerRedistributionFraction);
    }
    if (message.historicalEntries !== "0") {
      writer.uint32(64).int64(message.historicalEntries);
    }
    if (message.unbondingPeriod !== undefined) {
      Duration.encode(message.unbondingPeriod, writer.uint32(74).fork()).join();
    }
    if (message.softOptOutThreshold !== "") {
      writer.uint32(82).string(message.softOptOutThreshold);
    }
    for (const v of message.rewardDenoms) {
      writer.uint32(90).string(v!);
    }
    for (const v of message.providerRewardDenoms) {
      writer.uint32(98).string(v!);
    }
    if (message.retryDelayPeriod !== undefined) {
      Duration.encode(message.retryDelayPeriod, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumerParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumerParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blocksPerDistributionTransmission = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.distributionTransmissionChannel = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.providerFeePoolAddrStr = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ccvTimeoutPeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.transferTimeoutPeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.consumerRedistributionFraction = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.historicalEntries = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.unbondingPeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.softOptOutThreshold = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.rewardDenoms.push(reader.string());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.providerRewardDenoms.push(reader.string());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.retryDelayPeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumerParams {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      blocksPerDistributionTransmission: isSet(object.blocksPerDistributionTransmission)
        ? globalThis.String(object.blocksPerDistributionTransmission)
        : "0",
      distributionTransmissionChannel: isSet(object.distributionTransmissionChannel)
        ? globalThis.String(object.distributionTransmissionChannel)
        : "",
      providerFeePoolAddrStr: isSet(object.providerFeePoolAddrStr)
        ? globalThis.String(object.providerFeePoolAddrStr)
        : "",
      ccvTimeoutPeriod: isSet(object.ccvTimeoutPeriod) ? Duration.fromJSON(object.ccvTimeoutPeriod) : undefined,
      transferTimeoutPeriod: isSet(object.transferTimeoutPeriod)
        ? Duration.fromJSON(object.transferTimeoutPeriod)
        : undefined,
      consumerRedistributionFraction: isSet(object.consumerRedistributionFraction)
        ? globalThis.String(object.consumerRedistributionFraction)
        : "",
      historicalEntries: isSet(object.historicalEntries) ? globalThis.String(object.historicalEntries) : "0",
      unbondingPeriod: isSet(object.unbondingPeriod) ? Duration.fromJSON(object.unbondingPeriod) : undefined,
      softOptOutThreshold: isSet(object.softOptOutThreshold) ? globalThis.String(object.softOptOutThreshold) : "",
      rewardDenoms: globalThis.Array.isArray(object?.rewardDenoms)
        ? object.rewardDenoms.map((e: any) => globalThis.String(e))
        : [],
      providerRewardDenoms: globalThis.Array.isArray(object?.providerRewardDenoms)
        ? object.providerRewardDenoms.map((e: any) => globalThis.String(e))
        : [],
      retryDelayPeriod: isSet(object.retryDelayPeriod) ? Duration.fromJSON(object.retryDelayPeriod) : undefined,
    };
  },

  toJSON(message: ConsumerParams): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.blocksPerDistributionTransmission !== "0") {
      obj.blocksPerDistributionTransmission = message.blocksPerDistributionTransmission;
    }
    if (message.distributionTransmissionChannel !== "") {
      obj.distributionTransmissionChannel = message.distributionTransmissionChannel;
    }
    if (message.providerFeePoolAddrStr !== "") {
      obj.providerFeePoolAddrStr = message.providerFeePoolAddrStr;
    }
    if (message.ccvTimeoutPeriod !== undefined) {
      obj.ccvTimeoutPeriod = Duration.toJSON(message.ccvTimeoutPeriod);
    }
    if (message.transferTimeoutPeriod !== undefined) {
      obj.transferTimeoutPeriod = Duration.toJSON(message.transferTimeoutPeriod);
    }
    if (message.consumerRedistributionFraction !== "") {
      obj.consumerRedistributionFraction = message.consumerRedistributionFraction;
    }
    if (message.historicalEntries !== "0") {
      obj.historicalEntries = message.historicalEntries;
    }
    if (message.unbondingPeriod !== undefined) {
      obj.unbondingPeriod = Duration.toJSON(message.unbondingPeriod);
    }
    if (message.softOptOutThreshold !== "") {
      obj.softOptOutThreshold = message.softOptOutThreshold;
    }
    if (message.rewardDenoms?.length) {
      obj.rewardDenoms = message.rewardDenoms;
    }
    if (message.providerRewardDenoms?.length) {
      obj.providerRewardDenoms = message.providerRewardDenoms;
    }
    if (message.retryDelayPeriod !== undefined) {
      obj.retryDelayPeriod = Duration.toJSON(message.retryDelayPeriod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumerParams>, I>>(base?: I): ConsumerParams {
    return ConsumerParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumerParams>, I>>(object: I): ConsumerParams {
    const message = createBaseConsumerParams();
    message.enabled = object.enabled ?? false;
    message.blocksPerDistributionTransmission = object.blocksPerDistributionTransmission ?? "0";
    message.distributionTransmissionChannel = object.distributionTransmissionChannel ?? "";
    message.providerFeePoolAddrStr = object.providerFeePoolAddrStr ?? "";
    message.ccvTimeoutPeriod = (object.ccvTimeoutPeriod !== undefined && object.ccvTimeoutPeriod !== null)
      ? Duration.fromPartial(object.ccvTimeoutPeriod)
      : undefined;
    message.transferTimeoutPeriod =
      (object.transferTimeoutPeriod !== undefined && object.transferTimeoutPeriod !== null)
        ? Duration.fromPartial(object.transferTimeoutPeriod)
        : undefined;
    message.consumerRedistributionFraction = object.consumerRedistributionFraction ?? "";
    message.historicalEntries = object.historicalEntries ?? "0";
    message.unbondingPeriod = (object.unbondingPeriod !== undefined && object.unbondingPeriod !== null)
      ? Duration.fromPartial(object.unbondingPeriod)
      : undefined;
    message.softOptOutThreshold = object.softOptOutThreshold ?? "";
    message.rewardDenoms = object.rewardDenoms?.map((e) => e) || [];
    message.providerRewardDenoms = object.providerRewardDenoms?.map((e) => e) || [];
    message.retryDelayPeriod = (object.retryDelayPeriod !== undefined && object.retryDelayPeriod !== null)
      ? Duration.fromPartial(object.retryDelayPeriod)
      : undefined;
    return message;
  },
};

function createBaseConsumerGenesisState(): ConsumerGenesisState {
  return { params: undefined, provider: undefined, newChain: false };
}

export const ConsumerGenesisState: MessageFns<ConsumerGenesisState> = {
  encode(message: ConsumerGenesisState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      ConsumerParams.encode(message.params, writer.uint32(10).fork()).join();
    }
    if (message.provider !== undefined) {
      ProviderInfo.encode(message.provider, writer.uint32(18).fork()).join();
    }
    if (message.newChain !== false) {
      writer.uint32(24).bool(message.newChain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumerGenesisState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumerGenesisState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = ConsumerParams.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.provider = ProviderInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.newChain = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumerGenesisState {
    return {
      params: isSet(object.params) ? ConsumerParams.fromJSON(object.params) : undefined,
      provider: isSet(object.provider) ? ProviderInfo.fromJSON(object.provider) : undefined,
      newChain: isSet(object.newChain) ? globalThis.Boolean(object.newChain) : false,
    };
  },

  toJSON(message: ConsumerGenesisState): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = ConsumerParams.toJSON(message.params);
    }
    if (message.provider !== undefined) {
      obj.provider = ProviderInfo.toJSON(message.provider);
    }
    if (message.newChain !== false) {
      obj.newChain = message.newChain;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumerGenesisState>, I>>(base?: I): ConsumerGenesisState {
    return ConsumerGenesisState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumerGenesisState>, I>>(object: I): ConsumerGenesisState {
    const message = createBaseConsumerGenesisState();
    message.params = (object.params !== undefined && object.params !== null)
      ? ConsumerParams.fromPartial(object.params)
      : undefined;
    message.provider = (object.provider !== undefined && object.provider !== null)
      ? ProviderInfo.fromPartial(object.provider)
      : undefined;
    message.newChain = object.newChain ?? false;
    return message;
  },
};

function createBaseProviderInfo(): ProviderInfo {
  return { clientState: undefined, consensusState: undefined, initialValSet: [] };
}

export const ProviderInfo: MessageFns<ProviderInfo> = {
  encode(message: ProviderInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientState !== undefined) {
      ClientState.encode(message.clientState, writer.uint32(10).fork()).join();
    }
    if (message.consensusState !== undefined) {
      ConsensusState.encode(message.consensusState, writer.uint32(18).fork()).join();
    }
    for (const v of message.initialValSet) {
      ValidatorUpdate.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProviderInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientState = ClientState.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.consensusState = ConsensusState.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.initialValSet.push(ValidatorUpdate.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderInfo {
    return {
      clientState: isSet(object.clientState) ? ClientState.fromJSON(object.clientState) : undefined,
      consensusState: isSet(object.consensusState) ? ConsensusState.fromJSON(object.consensusState) : undefined,
      initialValSet: globalThis.Array.isArray(object?.initialValSet)
        ? object.initialValSet.map((e: any) => ValidatorUpdate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProviderInfo): unknown {
    const obj: any = {};
    if (message.clientState !== undefined) {
      obj.clientState = ClientState.toJSON(message.clientState);
    }
    if (message.consensusState !== undefined) {
      obj.consensusState = ConsensusState.toJSON(message.consensusState);
    }
    if (message.initialValSet?.length) {
      obj.initialValSet = message.initialValSet.map((e) => ValidatorUpdate.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProviderInfo>, I>>(base?: I): ProviderInfo {
    return ProviderInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProviderInfo>, I>>(object: I): ProviderInfo {
    const message = createBaseProviderInfo();
    message.clientState = (object.clientState !== undefined && object.clientState !== null)
      ? ClientState.fromPartial(object.clientState)
      : undefined;
    message.consensusState = (object.consensusState !== undefined && object.consensusState !== null)
      ? ConsensusState.fromPartial(object.consensusState)
      : undefined;
    message.initialValSet = object.initialValSet?.map((e) => ValidatorUpdate.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
