// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: interchain_security/bridge/state.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "interchain_security.bridge";

/** WithdrawalBalance represents a withdrawal balance for a public key */
export interface WithdrawalBalance {
    publicKey: string;
    amount: string;
}

/** RewardBalance represents a reward balance for a public key */
export interface RewardBalance {
    publicKey: string;
    amount: string;
}

/** PulsarAction represents an action in the Pulsar system */
export interface PulsarAction {
    publicKey: string;
    amount: string;
    /** "deposit", "withdrawal", "settlement" */
    actionType: string;
    blockHeight: string;
}

/** PulsarActionList represents a list of actions for storage */
export interface PulsarActionList {
    actions: PulsarAction[];
}

/** BridgeState represents the complete state of the bridge module */
export interface BridgeState {
    withdrawalBalances: WithdrawalBalance[];
    rewardBalances: RewardBalance[];
    approvedActions: PulsarAction[];
    approvedActionHash: string;
    allActionHash: string;
    settledBlockHeight: string;
}

function createBaseWithdrawalBalance(): WithdrawalBalance {
    return { publicKey: "", amount: "" };
}

export const WithdrawalBalance: MessageFns<WithdrawalBalance> = {
    encode(message: WithdrawalBalance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.publicKey !== "") {
            writer.uint32(10).string(message.publicKey);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): WithdrawalBalance {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWithdrawalBalance();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.publicKey = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }

                    message.amount = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): WithdrawalBalance {
        return {
            publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
            amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
        };
    },

    toJSON(message: WithdrawalBalance): unknown {
        const obj: any = {};
        if (message.publicKey !== "") {
            obj.publicKey = message.publicKey;
        }
        if (message.amount !== "") {
            obj.amount = message.amount;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<WithdrawalBalance>, I>>(base?: I): WithdrawalBalance {
        return WithdrawalBalance.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<WithdrawalBalance>, I>>(object: I): WithdrawalBalance {
        const message = createBaseWithdrawalBalance();
        message.publicKey = object.publicKey ?? "";
        message.amount = object.amount ?? "";
        return message;
    },
};

function createBaseRewardBalance(): RewardBalance {
    return { publicKey: "", amount: "" };
}

export const RewardBalance: MessageFns<RewardBalance> = {
    encode(message: RewardBalance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.publicKey !== "") {
            writer.uint32(10).string(message.publicKey);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): RewardBalance {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRewardBalance();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.publicKey = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }

                    message.amount = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): RewardBalance {
        return {
            publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
            amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
        };
    },

    toJSON(message: RewardBalance): unknown {
        const obj: any = {};
        if (message.publicKey !== "") {
            obj.publicKey = message.publicKey;
        }
        if (message.amount !== "") {
            obj.amount = message.amount;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<RewardBalance>, I>>(base?: I): RewardBalance {
        return RewardBalance.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<RewardBalance>, I>>(object: I): RewardBalance {
        const message = createBaseRewardBalance();
        message.publicKey = object.publicKey ?? "";
        message.amount = object.amount ?? "";
        return message;
    },
};

function createBasePulsarAction(): PulsarAction {
    return { publicKey: "", amount: "", actionType: "", blockHeight: "0" };
}

export const PulsarAction: MessageFns<PulsarAction> = {
    encode(message: PulsarAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.publicKey !== "") {
            writer.uint32(10).string(message.publicKey);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        if (message.actionType !== "") {
            writer.uint32(26).string(message.actionType);
        }
        if (message.blockHeight !== "0") {
            writer.uint32(32).uint64(message.blockHeight);
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): PulsarAction {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePulsarAction();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.publicKey = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }

                    message.amount = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }

                    message.actionType = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }

                    message.blockHeight = reader.uint64().toString();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): PulsarAction {
        return {
            publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
            amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
            actionType: isSet(object.actionType) ? globalThis.String(object.actionType) : "",
            blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
        };
    },

    toJSON(message: PulsarAction): unknown {
        const obj: any = {};
        if (message.publicKey !== "") {
            obj.publicKey = message.publicKey;
        }
        if (message.amount !== "") {
            obj.amount = message.amount;
        }
        if (message.actionType !== "") {
            obj.actionType = message.actionType;
        }
        if (message.blockHeight !== "0") {
            obj.blockHeight = message.blockHeight;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<PulsarAction>, I>>(base?: I): PulsarAction {
        return PulsarAction.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<PulsarAction>, I>>(object: I): PulsarAction {
        const message = createBasePulsarAction();
        message.publicKey = object.publicKey ?? "";
        message.amount = object.amount ?? "";
        message.actionType = object.actionType ?? "";
        message.blockHeight = object.blockHeight ?? "0";
        return message;
    },
};

function createBasePulsarActionList(): PulsarActionList {
    return { actions: [] };
}

export const PulsarActionList: MessageFns<PulsarActionList> = {
    encode(message: PulsarActionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        for (const v of message.actions) {
            PulsarAction.encode(v!, writer.uint32(10).fork()).join();
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): PulsarActionList {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePulsarActionList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.actions.push(PulsarAction.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): PulsarActionList {
        return {
            actions: globalThis.Array.isArray(object?.actions)
                ? object.actions.map((e: any) => PulsarAction.fromJSON(e))
                : [],
        };
    },

    toJSON(message: PulsarActionList): unknown {
        const obj: any = {};
        if (message.actions?.length) {
            obj.actions = message.actions.map((e) => PulsarAction.toJSON(e));
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<PulsarActionList>, I>>(base?: I): PulsarActionList {
        return PulsarActionList.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<PulsarActionList>, I>>(object: I): PulsarActionList {
        const message = createBasePulsarActionList();
        message.actions = object.actions?.map((e) => PulsarAction.fromPartial(e)) || [];
        return message;
    },
};

function createBaseBridgeState(): BridgeState {
    return {
        withdrawalBalances: [],
        rewardBalances: [],
        approvedActions: [],
        approvedActionHash: "",
        allActionHash: "",
        settledBlockHeight: "0",
    };
}

export const BridgeState: MessageFns<BridgeState> = {
    encode(message: BridgeState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        for (const v of message.withdrawalBalances) {
            WithdrawalBalance.encode(v!, writer.uint32(10).fork()).join();
        }
        for (const v of message.rewardBalances) {
            RewardBalance.encode(v!, writer.uint32(18).fork()).join();
        }
        for (const v of message.approvedActions) {
            PulsarAction.encode(v!, writer.uint32(26).fork()).join();
        }
        if (message.approvedActionHash !== "") {
            writer.uint32(34).string(message.approvedActionHash);
        }
        if (message.allActionHash !== "") {
            writer.uint32(42).string(message.allActionHash);
        }
        if (message.settledBlockHeight !== "0") {
            writer.uint32(48).uint64(message.settledBlockHeight);
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): BridgeState {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBridgeState();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.withdrawalBalances.push(
                        WithdrawalBalance.decode(reader, reader.uint32())
                    );
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }

                    message.rewardBalances.push(RewardBalance.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }

                    message.approvedActions.push(PulsarAction.decode(reader, reader.uint32()));
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }

                    message.approvedActionHash = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }

                    message.allActionHash = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }

                    message.settledBlockHeight = reader.uint64().toString();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): BridgeState {
        return {
            withdrawalBalances: globalThis.Array.isArray(object?.withdrawalBalances)
                ? object.withdrawalBalances.map((e: any) => WithdrawalBalance.fromJSON(e))
                : [],
            rewardBalances: globalThis.Array.isArray(object?.rewardBalances)
                ? object.rewardBalances.map((e: any) => RewardBalance.fromJSON(e))
                : [],
            approvedActions: globalThis.Array.isArray(object?.approvedActions)
                ? object.approvedActions.map((e: any) => PulsarAction.fromJSON(e))
                : [],
            approvedActionHash: isSet(object.approvedActionHash)
                ? globalThis.String(object.approvedActionHash)
                : "",
            allActionHash: isSet(object.allActionHash)
                ? globalThis.String(object.allActionHash)
                : "",
            settledBlockHeight: isSet(object.settledBlockHeight)
                ? globalThis.String(object.settledBlockHeight)
                : "0",
        };
    },

    toJSON(message: BridgeState): unknown {
        const obj: any = {};
        if (message.withdrawalBalances?.length) {
            obj.withdrawalBalances = message.withdrawalBalances.map((e) =>
                WithdrawalBalance.toJSON(e)
            );
        }
        if (message.rewardBalances?.length) {
            obj.rewardBalances = message.rewardBalances.map((e) => RewardBalance.toJSON(e));
        }
        if (message.approvedActions?.length) {
            obj.approvedActions = message.approvedActions.map((e) => PulsarAction.toJSON(e));
        }
        if (message.approvedActionHash !== "") {
            obj.approvedActionHash = message.approvedActionHash;
        }
        if (message.allActionHash !== "") {
            obj.allActionHash = message.allActionHash;
        }
        if (message.settledBlockHeight !== "0") {
            obj.settledBlockHeight = message.settledBlockHeight;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<BridgeState>, I>>(base?: I): BridgeState {
        return BridgeState.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<BridgeState>, I>>(object: I): BridgeState {
        const message = createBaseBridgeState();
        message.withdrawalBalances =
            object.withdrawalBalances?.map((e) => WithdrawalBalance.fromPartial(e)) || [];
        message.rewardBalances =
            object.rewardBalances?.map((e) => RewardBalance.fromPartial(e)) || [];
        message.approvedActions =
            object.approvedActions?.map((e) => PulsarAction.fromPartial(e)) || [];
        message.approvedActionHash = object.approvedActionHash ?? "";
        message.allActionHash = object.allActionHash ?? "";
        message.settledBlockHeight = object.settledBlockHeight ?? "0";
        return message;
    },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
    ? T
    : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
    ? ReadonlyArray<DeepPartial<U>>
    : T extends {}
    ? { [K in keyof T]?: DeepPartial<T[K]> }
    : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
    ? P
    : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
          [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
      };

function isSet(value: any): boolean {
    return value !== null && value !== undefined;
}

export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
